---
tags: [读源码, golang, 学习记录]
---

### 无关前言

没好好看过什么源码，从这个起步吧，结构非常简单，单文件。



大致想象要从什么方向去看，尽量自由一点，按照下面的方向选择性写就好了。

然后也不仅仅是一个记录方向，也是一个入手的方向。看的话肯定不是一个顺序的走向的。

1. 项目结构是什么样的，用了哪些设计模式
2. 有哪些你觉得写得好，换做是让你写的话，你写不出来的地方（项目能部分实现的话，直接 show me the code）？为什么换做是你，你没法解决这个开源项目所解决的问题？
3. 你使用这个项目的过程中，有没有遇到过什么好奇怎么实现的部分？或者有没有遇到过什么bug？从源码上是怎么出现的？
4. 如何总结这个开源项目的实现原理？





### 学习到的点

从更简洁的一个视角了解到的写好几个接口的基本步骤

- OAuth2 验证
- UnRoute 处理
- 处理空输入





反向代理的接口的注意事项

- 处理隐含可能出现的错误返回值



实现原理 / 反代实际帮忙做的事情

- 不是不能直接请求原来的API，实际上是简化请求，封装了 JSONRPC 的过程（JSON演化的众多用途的协议之一，已经是一种规范了，用于 RPC)
- 复杂反代封装还是很有意义的，相当于让服务器帮忙处理了很多层调用中的很多事情，调用方工作量简化了很多。
- 还有一个官方信用卡免费api模式用来做兜底，挺好的



知识点上的收获

- 居然还是第一次明白 `json.Marshal()` 的实际作用，其实只是一个在字节化前先转换为JSON字符串的过程而已，还是要多看源码。这里面就转了一下又转回来了，因为实际上是要对json字符串进行接口规范 adhere 处理
- 完整请求过程，创建客户端
- ioReader，学C的时候需要了解的东西，主要包含一个记录切片位置的地方，上一个字节是什么

- `gjson` 搜索json的实用util

### 疑问

1. 源码限定了一个请求id的范围，这个有关系吗？如果有，官方 API 做这个限定的目的是什么？
2. 根据id的余数确定了两种 `postStr` 的方式，`adhere to DeepL's request formatting rules` 确实还是复杂了
