---
tags: [GoLang, 知识点记录]
---



> 有时候也会像这样直接进行一些知识点的记录，不适合当作教程看，但尽量做到知识点写得很清楚，有 `知识点记录` 这个 tag 的应该都会这样



## 认识工作区



模块路径、模块名、文件夹名、文件名的区别：

- 模块路径：每个模块 `go.mod` 文件中 `module` 关键字后面的，一般会是 Github 仓库地址或者Go仓库地址，是导入的时候为了能直接从网上或者是本地找到的，也是 `go init [MODULE PATH]` 时候的最后一个参数

- 模块名：也是文件夹名或者一般是路径最后的那个名字。有个要点是一次只能导入一个包，不能导入一整个模块。

- 文件名：暂时没发现有什么用，可以继续归结一下函数的名字们倒是；然后叫做同一个包名的文件可以共享函数，也就是说文件就是包的进一步分解，最小的那个文件夹就是一个包，然后包里面的文件都必须标好这个包名，然后就随便了，可以看成一个整体；main在谁里面没关系，在哪个文件里导入包也没关系

  ![image-20230121174014026](https://f.pz.al/pzal/2023/01/21/c93e64f63f3dc.png)



工作区的逻辑层次大概是这样的：工作区 > 模块 > 包 > 函数

- 包是代码运行的最小单位，一般由一个文件夹构成，有时候也由单独的一个文件构成，就是一个包只组织了一个文件；然后就是包是也是导入导出的基本单位
-  `go.mod` 文件是以模块为单位进行管理的，很多时候我们一个模块里面也只有一个包
- 模块是我们一般进行开发的主要单位，里面会有不同的包相互配合，一个模块里面只有一个 `main` 包，是整个包的入口







工作区是 Golang 1.18 的新特性，最大的作用就是允许我们对相互依赖的「模块」进行开发

我没理解错的话，工作区就是使得我们恰好对几个功能逻辑上相互独立，但依然有点关联的一些模块进行了更高一层的抽象统一，可以适当节省一些资源。

## 工作区的使用



- 如果我们要导入的包，在工作区中已经存在了（下载下来了，和模块在同级目录），那会优先使用工作区中的本地模块（测试新加的函数可以用），类似于 `GO Ventor` 的逻辑（这个时候 `go.mod` 没有存依赖的版本，也就是不需要 `go get` ；这是因为导入包的时候也有一个类似于系统 `PATH` 变量的逻辑，会依次从**安装目录、当前工作区、直接网络访问那个路径**来寻找

- 创建了工作区以后，即已经有了 `go.work` 文件，那么没有加入工作区的模块都不会被视作是模块，使用本地工具的时候会有很多诧异的报错



待刷： [官方博文：Go 1.18 工作区模式最佳实践 - 知乎](https://zhuanlan.zhihu.com/p/495832968)



## 杂谈

- [Tutorial: Getting started with multi-module workspaces - The Go Programming Language](https://go.dev/doc/tutorial/workspaces#learn-more-about-workspaces) 这里面其实也没学啥，可能工作区管理就是一种管理好多个模块，让其一起工作的逻辑吧

  > 这个教程就是让你建一个模块，然后上级建立一个工作区，然后在工作区再拉取一个模块，然后修改这个拉取的模块，在原来的模块里面重新调用修改的模块




- 在把库里的包下载到本地然后用相对路径导入的话，有一个暂时还没懂的问题，导入的时候我们是用 `路径/模块/包` 这样导入的，然而下载到本地的时候 `go.mod` 也很合理地出现在了模块路径中，导致本地导入的时候会报错

  `stringutil: module ../example/stringutil: reading ..\example\stringutil\go.mod: open D:\Codes\GoCodes\testcodes\example\stringutil\go.mod: The system cannot find the file specified.` 

  就是没有找到 `go.mod` 文件，就很奇怪，看来依赖管理还没学好，特别是关于整个模块的依赖管理

