

> 大多数时间都会花在如何实现和调用接口
>
> 真正熟悉程序的唯一方法就是体验它

## Isolation



核心思想：

一个程序出问题的时候，不会影响另一个程序

程序出问题操作系统不会因此崩溃

进程之间互不干扰



稻草人提案法（头脑风暴找出不存在的时候的缺点）

—— 如果没有操作系统，会发生什么？

—— 应用程序直接操控硬件

有一些实时操作系统就是这样设计的，app之间相互信任

-  sh 可能永远不会释放 CPU 资源，无法实现 协同调度
  - Enforce multiplex 无法实现
- 没有人管理他们的内存空间，容易出现存储复写



所以操作系统接口 Unix Interface 是精心设计的，会强调这种隔离性

- 抽象硬件资源
- “进程”抽象了CPU：应用程序不能不能直接调用 CPU
  - CPU 是单线程分时复用的
- `exec()` 抽象了内存
  - 应用程序不能直接访问物理内存地址，操作系统提供类内存隔离，在app和硬件资源之间
- `files` 抽象了硬盘
  - 是唯一和存储系统交互的方式
  - OS 会决定如何将文件和磁盘对应，也会有用户之间的隔离



Q：OS 有没有可能在有多核的情况下将多个进程调度到同一个 CPU 核上？

A：会的。有个「缓存关联」 的概念。会在高性能网络之间介绍



`proc.c` 会简单实现 multiplex 多路复用

> 前面几节课是对大多数内容的概述



防御性：

- 抵御恶意程序的攻击

- 需要防止独立性的打破，控制内核
  - 内核具有所有硬件的控制权
    - 内核需要具有防御性



需要在 APP 和 OS 之间提供强隔离性

一般也是需要**硬件支持**

- 内核模式 / 监督模式
- 虚拟内存



### User / Kernel Mode

- 非特权指令就是一些简单的基本指令，所有程序都能运行的
- 特权指令：操作硬件、设置指令（大多数时间都会和直接源码打交道）



Q：是谁监督这些指令是否允许被执行？

A：CPU 会有一个 bit 的标志位，这个 bit 是被保护的

- 会有一个常常不需要被考虑的 Machine Mode



Q：如果说修改 bit 位的指令本身就是特权指令，那普通用户要如何访问内核，如何解决这个矛盾呢？



### Virtual Memory

- 页表：将虚拟地址映射到物理地址
- 每一个进程会有自己的一个独立的页表，只能用自己的内存，没有办法创建地址，每个进程都有自己独立的内存视图
- **实现了内存的隔离性**



### Enter Kernel

- 靠 ecall 命令，作用就是进入内核
  - 从用户空间转换到内核空间
  - 内核空间和用户空间之间是有一个硬性空间的。
  - 任何系统调用函数都封装了一个 ecall，然后吧控制权交给 `syscall` 







选择C的原因

- 因为他自带了很多对系统资源的控制

- > 只要配置好堆栈和中断它就能够运行，不需要其他环境





内核有时候也被叫做：可信任的计算基 TCB

- 首先要没有漏洞
- 必须要将用户进程当作是恶意的



什么程序应该运行在 Kernel Mode



两种【设计内核的方式】

- 宏内核：容易出现漏洞
  - XV6 是宏内核

- 微内核：
  - 很多内核程序可能实际代码在用户空间
  - 内核的代码很少，bug少
  - 跳转很多，内核跳转到用户空间来执行内核代码




## Xv6 介绍

- QEMU 用 C 语言模拟 RISC-V
- 实际应该按照主板的实物图去理解
- 主要做的事情就是一个取指令，读指令，执行指令的一个循环



- QMEU 有一个 GDB-Server，可以连接运行环境另外运行的一个 GDB



- 调试运行内核的代码
  - 看到 kernel 一步步进行初始化
  - 进入 syscall
    - 直接运行的代码，实际上对应一个汇编程序

看不懂，从汇编等级，搞清楚一切发生的事情，太难了



## System Call



一些最简单的系统调用的例子：

[Index of /2022/lec/l-overview](https://pdos.csail.mit.edu/6.S081/2022/lec/l-overview/)

