---
tags: [题解, 写了挺久的]
---





引子是重学两个板子题



### 整数二分

这个题目很久以前做过，算是一个二分比较复杂的模板题，没写过题解，还是打算拉出来讲一下







二分STL的介绍：

- 因为用得特别多，我觉得还是有必要深入了解一下的
- 简单记忆为，对于我们要找的值， $val \in [lb, rb)$ 
- 分别定义为，整个范围内，`lower_bound(), upper_bound()` 分别返回第一个小于等于 $val$ 的数和第一个大于 $val$ 的数



```c++
void query(vector<int> a, int q){
    
    auto lb = lower_bound(all(a), q), ub = upper_bound(all(a), q), st = a.begin();

    if(ub - lb)
        cout << lb - st << ' ' << ub - st - 1 << '\n';
    else 
        cout << -1 << ' ' << -1 << '\n';
    
}
```





### 浮点二分&二分答案intro

顺便来说一下另一个浮点二分 + 简单的二分答案



浮点二分比整数二分简单无数倍，直接看代码注意几个要点就好了

1. 注意所有地方都要用 `double` （我这个傻逼两个地方写了int，找bug还依次找了找了好久，还是得带脑子写代码啊）;
2. 注意浮点数不能完全“夹逼”，需要设置精度。

```c++
const double eps = 1e-8;

int main()
{
    double x; cin >> x;
    
    auto check = [&](double q){//
        return q * q * q >= x;
    };
    
    double l = -10000, r = 10000;//
    while(r - l > eps){//
        double m = (l + r) / 2;
        if(check(m)) r = m;
        else l = m;
    }
    
    printf("%lf\n", r);
    
    return 0;
}

```



然后这题其实是一个简单到一个不像二分答案的二分答案，正是因为简单，也值得拿出来说一下，更好掌握二分答案的本质，这就像斐波那契数列的递推求法实际上是个简单的动态规划一样。



二分答案其实是一种思想，然后引出了一种比较固定的思维模式。



姑且概括为：当想不到什么方法直接**顺次推理**得到答案的时候，我们可以直接尝试**猜**答案。

1. 猜不是随便猜，类比二分改进暴搜；
2. 二分条件：当答案所有可能的取值满足一连续段大于答案，一连续段小于答案



拿这个题目举例：

答案所有可能的取值可以分为两段

一般二分答案难就难在 `check()` 函数，所以很重要的一个点是一定要封装着当作一个子问题去理解

`check()` 的目的就是**检查答案应该在相较于条件的哪段**，显然我们可以根据：
$$
\sqrt[3]x \geq mid \Rightarrow x \geq mid \times mid \times mid
$$
得到 `check(mid)` 的判断表达式

注意这里因为**分界条件**比较简单，我们可以任意分段，只要能使得答案在两边就行了



### 整数二分答案

浮点二分答案简单，但是整数二分答案要考虑的就多了（待更新



想理解清楚，我们可以把所有整数二分答案的情况都写出来

区分点有这些：

- `true` 区间，即满足 `chekc()` 函数的区间是是在左还是在右
- 这个区间是否包含答案，即是开区间还是闭区间

它们分别决定

- 区间选择。满足条件的时候选左区间还是右区间
- 分区间的方式。我们选择了区间以后，对应的区间只能有一个包含中点，我们要做的就是让答案始终在我们要移动的区间之内。



二分难的地方还是没法用语言来将清楚，很多模糊的地方

图片其次，最好的理解还是视频



首先用最简单的理解来理解一下，在序列 $1 \sim 6$ 中搜索 $5$

我们选择 `check()` 条件为， $x \gt 5$ ，条件满足时取左区间

这个时候我们就应该用 `[l, mid - 1]` 和 `[mid, r]` 的区间划分方式，因为我们要找的 $5$ 它在右区间，所以我们要选择中点在右区间的划分方式



以下演示为什么选择 `[l, mid] ` 和 `[mid + 1, r]` 的区间划分方式（此时对应偶数中点取 $floor$ , `mid = (l + r) / 2` ）找不到答案

```
1 2 3 4 5 6
mid = 3 > tar = 5 false 取右区间
4 5 6
mid = 5 > tar = 5 false 取右区间
6
mid = 6 > tar = 5 true 取左区间
6
mid = 6 死循环
```



`[l, mid - 1]` 和 `[mid, r]` 的区间划分方式 `mid = (l + r + 1) / 2`

```
1 2 3 4 5 6
mid = 4 > tar = 5 false 取右区间
4 5 6
mid = 5 > tar = 5 false 取右区间
5 6
mid = 6 > tar = 5 true 取左区间
5
mid = 5 > tar = 5 false
l == r 跳出循环
```





总结来说如图所示



我们来几个简单例子来理解一下



我们尝试用多种方式来实现这个的二分



~~实在不会的话，反正true区间可以自己决定，然后两种区间方式都尝试一遍就好了~~

