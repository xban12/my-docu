---
tags: [操作系统
---



## 01 操作系统概述 

> 不要对编程抱有一切侥幸心理

### 什么是操作系统



为什么要学？

>  它可以给你关于编程的一切东西





什么是操作系统？

：管理软硬件资源，为程序提供服务

OSTEP：

- 程序的 body
- 使得可以更 easy 运行程序
- more fun fact





#### 历史

1940s 的计算机

- 计算机系统就是状态机

- 内存是用“丢球“的方式来处理的
- 能把程序放上去就不错了



1950s

- 出现 FORTEN 编程语言
- 使用打孔的方式来写语句，非常昂贵
- 于是出现了 OS 来管理，多程序，多用户



> 所有概念的出现都是很自然的





1960s

- 出现了大内存
- 但是只有一个CPU
- 可以放进去两个程序，**同时将多个程序载入内存**
  - 两个程序可以交替运行
  - Multi-Programming
  - 出现了切换程序的中断机制



1970s

- 已经出现了个人电脑了
- 复杂指令集
- 现在有的大多数事情当时已经出现了





现在的操作系统

- 更复杂的处理器和内存
- 更多的设备和硬件资源
  - 更复杂的应用需求和环境





#### 理解操作性系统



- 操作系统为程序（状态机）提供服务
- 如何从应用视角设计，提供什么样的服务
  - 操作系统其实就是：对象 + API
- 如何在硬件视角实现
  - 其实就是 C程序



### 怎么学

> “机器永远是对的，我肯定能调出来”

- 用正确的方法调试



> 命令行 + 浏览器就可以创造世界

写代码 = 创造有用的东西



> Talk is cheap, show me the code 





## 02 应用视角的操作系统

- 操作系统的三条主线，软硬件和作为中间件的操作系统
- 理解好服务对象：程序



> 搞清楚要了解的事情，你和专家的差距，就只差提出正确的问题了。

汇编寄存器说明：[ot all registers are described in this capture though. For instance *ipis a special register (process counter) that holds the next instruction to be executed. You can find the full ABI there. Some information is specific to Linux but most remains relevant for any POSIX-compliant system.](https://stackoverflow.com/questions/58852308/what-s-the-difference-between-eax-ebx-and-ecx-in-assembly)

### 汇编代码和最小可执行文件

> 最小的程序是什么？

- 真不小：查看链接的库，所有编译选项和链接选项

为什么死循环可以正常运行，而去掉死循环只有入口的时候就会 SE， crash？

- gdb 调试可以发现 `ret` 恢复栈帧的时候， `$rsp` 的值是 `1` 是一个不合法的值



> 去看 GDB 的手册，了解能做些什么事情

- 纯执行指令没法中止程序，我们用一条特殊的指令，用系统调用可以中止程序
- syscall 就是完全把程序状态机（内存 + 寄存器）交出去，就相当于做了全麻手术，后面交给OS来处理你



**程序是计算和系统调用组成的状态机**

> 搜索引擎是拉开中美大学生的差距的一个重要的因素，多去问出正确的问题



补充

- 汇编里的 `#include` 其实就是  `gcc` 的一个预处理，有一个标志会区分目前是什么代码

> ABI（Application Binary Interface，应用二进制接口）是一个软件接口的标准，用于不同编译器和操作系统之间进行交互。ABI定义了函数调用、参数传递、内存布局、异常处理等方面的规范，以确保不同对象文件能够正确地连接在一起，并在运行时相互协作。它是编译器和操作系统之间的一种契约，同时也为开发者提供了一种稳定的API，以便他们可以更轻松地开发跨平台的应用程序和系统。常见的ABI标准包括x86、ARM、MIPS等。





### 汇编代码的状态机模型

- 计算机=数电=状态

- 初始状态。由 ABI 规定
- 状态迁移（《计算机体系结构》）



学习目标：理解了这些，你可以简化所有C语言程序，没有函数，没有控制流，就像处理器只有内存、寄存器、移位一样。

- 只需要赋值运算if、goto

- 真的有这样的工具，或者说解释器

- 这其实就是编译器做的事情。所谓的编译器，其实就是把高级语言翻译成状态机



理解栈帧和函数调用

- 每一个栈帧都有一个 PC
- 函数调用就是**创建新的栈帧**，并让指令入栈（放入新的参数）
- 函数的返回（出栈）
- 函数的执行：取 topmost 的 PC 然后执行



例子：

- 非递归的汉诺塔
  - `.pc = 0` `f->pc++` 是在模拟函数执行的过程，跳转到一个新的栈，然后把要执行的PC都压进来逐步执行
  - 递归调用主要是创建新的栈帧结构体实现的。我们要理解 `for` 语句，`f` 每一次会更新为新的栈帧，然后通过 `f->pc++` 来执行栈内的指令 

- 两个递归函数



状态机定义



> 任何真正的理解都可以落实到可执行的代码

### 理解编译器

编译正确性

- `.c` 中外部观测者可见的行为，必须在 `.s` 中保持一致





## 硬件视角的操作系统



计算机硬件的状态模型

- 不只是程序，整个计算机系统都是状态机
- 初始状态：就是手册上规定的 CPU Reset
  - CPU厂商给OS电脑生产厂商Bare-metal
  - 那些CPU不预设的东西就是一些固件，厂商为OS开发者提供的
- 状态迁移



CPU Reset

- x86 可以在手册上找到
- Reset 后 CPU 都从固定地址 Reset vector 启动

- 固件负责加载操作系统
  - 开发板
  - QEMU
    - `-kernel` 绕过内核加载



Reset 之后，到底执行了什么

- 开始执行状态机
- 固件
  - 管理配置硬件的小OS
  - (Legacy) BIOS
    - 历史：BIOS有个接口，没有专利，所有BIOS可以接入其他很多“兼容机”
    - 约定：将程序员代码载入内存（没怎么听懂）
  - UEFI (BIOS)
    - 解决了BIOS碎片化，需要很多驱动



有没有可能真的去看到 Reset 以后每一条指令的执行

> 计算机系统公理：你能想到的就一定有人做到

- 模拟方案：
  - GDB 调试 QEMU，Watch point 很重要

- 真机方案



UEFI 的系统加载



标准化的加载流程

- GPT 磁盘分区
- 预留一个 FAT32 分区
- 可以加载任意大小（不止512字节的）PE文件 `.efi`

更好的程序支持

- 驱动框架
- 更多功能，比如安全OS启动





我们已经获得能力

- 直接硬件编程
  - 机器运行指令序列
  - 任何状态机
- 操作系统：Clang
  - BIOS 完成磁盘内存的加载
  - 
