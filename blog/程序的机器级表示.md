---
tags: [知识点记录, CSAPP, 写了挺久的]
---





(这套体系仅供参考，和原书不一样)

## 基础



### Intel 处理器历史和架构



ARM：

（参考[ARM64指的是什么？与x86什么区别？ - 知乎](https://zhuanlan.zhihu.com/p/508557771) ）

- ARM64 现在一般指 ARMv8 是ARM 公司发布的第一代支持64位处理器的指令集和体系结构
- ARM 一般作为 RISC 的代名词，是现在很多处理器的基础，一般是作为 IP 的一个销售商
- 和 ARM 相对的是 X86 架构，也就是CISC



- RISC-V：也是RISC的ISA，但是是开源的



时代更迭，历史上出现过很多成功的 ISA，但如今主流的只剩下他们三个：

![](https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MWgZhdxjCTP2zYJjb5i%2F-MWg_RFiii0e5z1ZSRwD%2F%E6%8D%95%E8%8E%B7.PNG?alt=media&token=ff458719-33de-4718-b1a6-81bbacc3f8ef)



### 编程语言

> C语言、汇编语言、机器语言

一些定义：

- Architecture / ISA：（指令）体系架构，如指令集规范、寄存器的设置
- 微结构：ISA的具体实现，如CACHE的设置和核心的频率
- 代码形式
  - 机器代码
  - 汇编代码



编译系统：

![image-20230111101447808](https://s2.loli.net/2023/01/11/hWAVeZFTojbfJC7.png)



机器级程序员可见的部分：

![](https://photo.sibnet.ru/upload/imggreat/1673059532831477855.jpg)



编译成汇编代码：

- `gcc -Og -S sample.c` 进行可读性优化编译，并在汇编代码处 Stop 编译
- 以 `.` 开头的汇编代码是一些给调试器提供信息定位的一些附带信息，可以完全忽略
- datalab  鲨鱼机？



汇编语言的特征：

- 数据类型
  - 整形：数值、地址
  - 浮点数
  - 由指令编译出的代码
  - 无数据结构
    - 机器级编程无法实现
    - 由编译器人工构造
    - 主要是在内存中连续分配
- 操作：单个的指令在能做到的事情上非常有限
  - 对内存和寄存器数据进行算数运算
  - 内存和寄存器之间的数据传输
  - 传输控制：跳转、分支



反汇编：

- 反汇编程序不会访问源代码和汇编代码，是直接根据可执行的二进制代码得出的
- 任何程序都可以解释为可执行的代码，汇编器检查二进制代码并重构它们



### 汇编基础

寄存器：

- 寄存器 e(extented) 版本比 r版本更大（32位版本和64位版本，实质上硬件不变，操控不同位）
- 现在除了基址寄存器 `%rbp` 和栈指针寄存器 `%rsp` ，其他都是通用寄存器，名字是历史遗留问题
- 但是其实通用寄存器也有一些偏好，也就是会有一些优先的用途
  - `%rax` `%eax` 常常用来存返回值，也经常作为中转点，刚刚移动过去就会 `mov` 出去	
  - di si dx cx r8 r9 会依次作为【被调用者保存寄存器】用来存函数参数
  - 【调用者保存寄存器】 bx bp 12 13 14 15
- https://stackoverflow.com/questions/58852308/what-s-the-difference-between-eax-ebx-and-ecx-in-assembly

移动数据：

- 操作数类型：立即数（用 `$` 开头）、寄存器、内存

- 操作数结合使用

  ![](https://photo.sibnet.ru/upload/imggreat/1673331940171477855.jpg)

- `movq D(R1), R2`

  - q (quad) 四字 64 bit Intel 以前一字是 16 bit

    - 类似的还有 b\w\l\s (byte\word\double word)
    - rax eax ax al 分别从长到短对不同寄存器的数位进行操作
  - 有 movsb、movsw 和 movsd 三条指令，它们的作用是将一个字节、一个字或一个双字从一个位置移动到另一个位置。
  
- 表示 `R1` 基址偏移 `D` 个位置 `Mem[Reg(R) + D]` 寻址
  
- 更一般的地址计算形式：立即数 + 基址 + 比例因子 \* 变址
  
  ![image-20230110210247994](https://s2.loli.net/2023/01/10/NzLKbtuEiPAoqGa.png)



- 调用者保存与被调用者保存
  - 在调用函数或者被调用函数的开头结束存储恢复局部代码的值
- 栈操作
  ![](https://cdn.nlark.com/yuque/0/2023/png/12681739/1673405531665-9790521b-2bd1-43c7-9879-14e7c27b88be.png?x-oss-process=image%2Fresize%2Cw_1327%2Climit_0)
  - 栈本质上是内存中的一篇区域

  - 栈从高地址往低地址延展

  - 栈指令可以等效成更长的两个指令
- `leaq` 基本类似于 `moveq` ，功能是加载
- 编译器会不断寻找各种更聪明的汇编方法来实现高级语言



## 流程控制



> 条件，指令的顺序是根据什么控制的呢？

### 指令与条件码

- ALU会根据运算结果设定**条件码寄存器**
- CZSO 进位、零、符号、溢出，分别为前两位和后两位
- 不同的指令会对条件码有不同的影响，其中 `TEST` 和 `CMP`指令比较特殊，它们只更新条件码寄存器的值，不更新目标寄存器的值。
- 在实际的大小比较中我们要用到 `SETE`和 `SETL` 等指令，他们的作用是根据条件码寄存器来设定寄存器的值，以保存条件判断的结果
  - 小于可以通过 “溢出”和“符号”的条件异或和的结果来判断
  - 类似地，可以用条件码的逻辑组合做出任何判断

### 跳转和循环

> 理解汇编代码就是机器语言的不同程度的优化，仔细研究汇编代码可以发现编译器的聪明之处


- 数据的条件转移代替控制的条件转移，条件传送代替跳转效率会更高
  - 现代处理器主要通过流水线分支预测来获得高性能的，会对条件跳转指令进行预测，错误预测会浪费大量时间。
  - 分支预测：程序在还没运行前就根据代码猜测可能会运行哪些分支

- 循环的实现：条件测试 + 跳转

- switch 通过跳转表处理多重分支使得跳转效率高
  - 跳转表即存代码位置地址的一个数组
  - 代码量更少，比较次数少，一次比较查表跳转

## 过程调用



认识过程：

- 过程并不是描述整个代码运行流程一个术语，而表示的是代码的一个部分，是软件中非常重要的一种抽象
- 不同语言的语言的「过程」形式不一（function, method, subroutine, handler)，但是也有一些共同的特性：
  1. 传递控制。切换过程的时候把原来下一条指令的地址压栈，然后将程序计数器设置为过程的第一条指令。
  2. 传递数据。必须向过程传参以及必须返回值？
  3. 分配和释放空间。比如本地变量暂时存到栈里面。



###  The Run-Time Stack

- x86-64虚拟地址空间中的栈向低地址方向延展，栈指针 `%rsp` 指向栈顶低地址

  ![image-20230114111927984](https://f.pz.al/pzal/2023/01/14/1a8cf6461d356.png)

- 栈帧：x86-64这种ISA中的过程需要的存储空间寄存器放不下的时候，超出的部分就会被分配到栈上。

  栈帧被依次用于：

  1. 较早的帧
  2. 传递参数
  3. 存储返回地址
  4. 存储保存的寄存器
  5. 存储局部变量
  6. 局部参数构造



![image-20230114124929756](https://f.pz.al/pzal/2023/01/14/24511b3693083.png)

> 例子：只有六个寄存器，多出来的部分存入 Stack Frame

（x64中栈无论数据类型的长度都是按8对齐的)



### 转移控制

函数调用返回的过程

1. call 先把返回地址压入栈中
2. ret 然后等函数（过程）执行完毕，弹出之前压入的地址，存入指令寄存器中

![image-20230114113122424](https://f.pz.al/pzal/2023/01/14/268af63fc0a9d.png)



一个函数调用大致的结构

```assembly
<main>:
	...
	call <func>
	...

<func>:
	push %rbx
	mov %rsp, %rbp
	...
	pop %rbx
	ret
```



稍微复杂一点的

```assembly
; 函数调用前需要将参数压入栈中
pushq   %parameter1
pushq   %parameter2
...

; 函数开始
func:
    ; 为局部变量分配空间
    subq    $local_variable_space, %rsp

    ; 保存寄存器
    pushq   %rbx
    pushq   %r12
    pushq   %r13
    ...

    ; 设置栈帧
    movq    %rsp, %rbp

    ; 函数体
    ...

    ; 恢复寄存器
    popq    %r13
    popq    %r12
    popq    %rbx
    ...

    ; 清理栈帧
    leave

    ; 返回
    ret

```





顺带记录一下指令寄存器（IR）和程序计数器（PC / `%rip`）的区别：

|      |        存的内容        |                   说明                   |
| :--: | :--------------------: | :--------------------------------------: |
|  IR  | 下一条要执行的指令本身 |     和汇编代码的指令寄存说明有些不同     |
|  PC  |   正在执行的指令地址   | 要是没跳转就能够直接 $+1$ 指向下一条指令 |





### 数据传送

- 通过栈来传递参数的时候，会在栈里面对齐（局部变量不用

- 传参使用寄存器的时候是有顺序规定的

  - 和参数序号和和操作数长度有关
  - callee 和 calling 固定的顺序（下面有
  
  ![image-20230114125415927](https://f.pz.al/pzal/2023/01/14/0bb406646cde8.png)



### 局部存储

#### 栈上局部存储

- 栈通过加减 `%rsp` 来分配和释放空间，提供「内存分配与回收机制」
- 这里可以实例性地看到寄存器存储参数和栈帧存储的不同

 ![image-20230114125618040](https://f.pz.al/pzal/2023/01/14/a18209a52beb3.png)



#### 寄存器上局部存储

- 寄存器分为两类

  ![image-20230114134439063](https://f.pz.al/pzal/2023/01/14/9729e0a81d31c.png)

  其区别就是在哪个函数的指令段压栈

> 1. 调用者寄存器是在调用函数前被使用的，因为这些寄存器一般用来存储参数、返回值和临时变量等数据。
> 2. 被调用者寄存器则在函数调用过程中被使用，包括用于存储函数参数、局部变量、函数返回值等。





- 了解递归函数调用的过程
  ![image-20230114135600574](https://f.pz.al/pzal/2023/01/14/de2eafc32ca02.png)
  - `.L35` 就是一个条件跳转的标记（Label)，这里表示递归出口
  - 每个函数都有各自私有的状态信息，而当他们需要访问状态信息的时候正好和栈的弹出顺序相同
  - 各自的栈帧是相对独立的，地址也不是连续的





***



## arv：

### 几个汇编注释例



01

```
int add(int a, int b) {
    return a + b;
}
```

对应的汇编代码：

```
add:
    pushl %ebp          ; 保存旧的基址指针
    movl %esp, %ebp     ; 设置新的基址指针
    movl 8(%ebp), %eax  ; 将第一个参数 a 存入 eax
    addl 12(%ebp), %eax ; 将第二个参数 b 加到 eax 上
    popl %ebp           ; 恢复旧的基址指针
    ret                 ; 返回结果
```



02


```
int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
```

对应的汇编代码：

```
factorial:
    pushl %ebp          ; 保存旧的基址指针
    movl %esp, %ebp     ; 设置新的基址指针
    cmpl $0, 8(%ebp)    ; 判断 n 是否等于 0
    jne .L2             ; 如果 n 不等于 0，跳转到 .L2 标签处
    movl $1, %eax       ; 如果 n 等于 0，将 1 存入 eax 中
    jmp .L1             ; 跳转到 .L1 标签处
.L2:
    movl 8(%ebp), %eax  ; 将 n 存入 eax 中
    subl $1, %eax       ; 将 n 减 1 后存回 eax 中
    pushl %eax          ; 将 n - 1 压入堆栈
    call factorial      ; 递归调用 factorial 函数
    imull 8(%ebp), %eax ; 将 n 与递归结果相乘
.L1:
    popl %ebp           ; 恢复旧的基址指针
    ret                 ; 返回结果
```



03 scanf 实现

```assembly
   0x5555555551a4 <main+27>        lea    -0x10(%rbp),%rax    ; 取输入值，放入被调用者寄存器
   0x5555555551a8 <main+31>        mov    %rax,%rsi         ; 转移到%rsi     
   0x5555555551ab <main+34>        lea    0xe52(%rip),%rdi    ; 取格式化字符串，放入另一个 callee 寄存器
   0x5555555551b2 <main+41>        mov    $0x0,%eax			; 放返回值
   调用
```



### 有关调用过程中寄存器变化的具体说明

一般情况下，调用者会将被调用函数的地址（即函数的基址）压入栈中，然后通过 `call` 指令来跳转到被调用函数的代码中执行。被调用函数通过访问栈中的参数来获取调用者传递的参数和函数基址。

下面是一个简洁的伪代码示例，假设调用者需要调用一个名为 `foo` 的函数，并将其基址传递给被调用者：

```
push foo_address  ; 将函数基址压入栈中
push parameter1   ; 将函数参数1压入栈中
push parameter2   ; 将函数参数2压入栈中
call foo          ; 调用函数
```

在被调用函数中，可以通过以下方式获取参数和函数基址：

```
foo:
    push rbp        ; 保存调用者的栈帧指针
    mov rbp, rsp    ; 设置当前栈帧指针
    mov rdi, [rbp+8] ; 获取参数1
    mov rsi, [rbp+16] ; 获取参数2
    mov rax, [rbp+24] ; 获取函数基址
    ...
    leave           ; 清理栈帧
    ret             ; 返回
```

其中，`rbp` 是当前栈帧的指针，`[rbp+8]`、`[rbp+16]` 和 `[rbp+24]` 分别是参数1、参数2 和函数基址在栈中的偏移量。



在 `call` 指令执行之前，CPU 会将当前指令的下一条指令地址（即 `call` 指令后面的指令地址）压入栈中，作为返回地址。然后，CPU 会将被调用函数的地址（即 `foo` 函数的地址）压入栈中，作为 `call` 指令的参数。这个过程会导致栈指针 `rsp` 的值发生变化。

具体来说，在 `call` 指令执行之前，`rsp` 的值是指向当前指令的下一条指令地址的。执行 `call` 指令时，CPU 会将下一条指令地址压入栈中，并将 `foo` 函数的地址压入栈中，同时将 `rsp` 的值减去 8（因为栈中压入了两个 8 字节的值）。这样，`rsp` 的值就指向了 `foo` 函数的返回地址，即被调用函数执行完毕后应该返回的地址。

被调用函数在执行时，可以从栈中获取参数和返回地址，执行完毕后通过 `ret` 指令返回到调用者，并将返回地址弹出栈。这个过程会导致 `rsp` 的值再次发生变化。
