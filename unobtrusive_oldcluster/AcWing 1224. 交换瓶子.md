---
tags: [题解, 蓝桥杯, 学习记录]
---

# AcWing 1224. 交换瓶子

不得不说这题还是有点意思的，让我久违地感觉离散数学确实是一种研究的工具，顺便水水题解吧



置换群的知识体系大致是

群论（群的概念） -> 置换 -> 置换群



这里我们其实只要了解置换是什么就行了

置换其实就是双射，可以理解为由一个序列和一个序列的重排构成，然后这样的两组序列就构成双摄，画成图可以清楚地看到置换是由轮换的积构成的



当然这些都不是重点，这题的用到的结论是：**可以发现，在一个轮换中，交换两个元素，必定会分裂成两个轮换**



所以这题就简单了，两个统计思路



1. 统计出各个环有多少个元素，然后长度大于1的环需要分裂 n - 1 次，各个环需要分解的次数加起来就好了

   ```c++
   const int N = 10010;
   
   int n;
   int b[N];
   bool st[N];
   
   int main()
   {
       cin >> n;
       for(int i = 1; i <= n; ++i) cin >> b[i];
       
       vector<int> cnts;
       for(int i = 1; i <= n; ++i) {
           int from = i, to = b[i], cnt = 0;
           while(!st[to]) ++cnt, st[to] = true, from = to, to = b[from]; 
           if(cnt) cnts.push_back(cnt);
       }
       
       int sum = 0;
       for(int i : cnts) 
           sum += (i - 1);
           // cout << i << ' ';
       
       cout << sum;
       
       return 0;
   }
   
   ```

2. 考虑 $n$ 个元素是一个整环，我们最终需要n个环，分裂一次环数 + 1，所以一共需要分裂 $n - 1$ 次；而现在假设我们有 $k$ 个环了，就相当于已经分解了 $k - 1$ 次了，所以我们只要用 $n - k$ 即可直接得到答案

   代码（这种统计环数的方法更优雅：
   ```c++
   int cnt = 0;
       for(int i = 1; i <= n; ++i) if(!st[i]){
           ++cnt;
           for(int j = i; !st[j]; j = b[j]) st[j] = true;
       }
       
       cout << n - cnt;
   ```





（犯了一个比较nc的问题是忘记下标不能从零开始了，这种下标有实际意义而不只是存储的还是得重视起来，不能只依靠惯性写了）