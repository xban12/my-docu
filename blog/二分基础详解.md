---
tags: [题解, 写了挺久的]
---





引子是重学两个板子题



### 整数二分

这个题目很久以前做过，算是一个二分比较复杂的模板题，没写过题解，还是打算拉出来讲一下







二分STL的介绍：

- 因为用得特别多，我觉得还是有必要深入了解一下的
- 简单记忆为，对于我们要找的值， $val \in [lb, rb)$ 
- 分别定义为，整个范围内，`lower_bound(), upper_bound()` 分别返回第一个小于等于 $val$ 的数和第一个大于 $val$ 的数



```c++
void query(vector<int> a, int q){
    
    auto lb = lower_bound(all(a), q), ub = upper_bound(all(a), q), st = a.begin();

    if(ub - lb)
        cout << lb - st << ' ' << ub - st - 1 << '\n';
    else 
        cout << -1 << ' ' << -1 << '\n';
    
}
```





### 浮点二分&二分答案intro

顺便来说一下另一个浮点二分 + 简单的二分答案



浮点二分比整数二分简单无数倍，直接看代码注意几个要点就好了

1. 注意所有地方都要用 `double` （我这个傻逼两个地方写了int，找bug还依次找了找了好久，还是得带脑子写代码啊）;
2. 注意浮点数不能完全“夹逼”，需要设置精度。

```c++
const double eps = 1e-8;

int main()
{
    double x; cin >> x;
    
    auto check = [&](double q){//
        return q * q * q >= x;
    };
    
    double l = -10000, r = 10000;//
    while(r - l > eps){//
        double m = (l + r) / 2;
        if(check(m)) r = m;
        else l = m;
    }
    
    printf("%lf\n", r);
    
    return 0;
}

```



然后这题其实是一个简单到一个不像二分答案的二分答案，正是因为简单，也值得拿出来说一下，更好掌握二分答案的本质，这就像斐波那契数列的递推求法实际上是个简单的动态规划一样。



二分答案其实是一种思想，然后引出了一种比较固定的思维模式。



姑且概括为：当想不到什么方法直接**顺次推理**得到答案的时候，我们可以直接尝试**猜**答案。

1. 猜不是随便猜，类比二分改进暴搜；
2. 二分条件：当答案所有可能的取值满足一连续段大于答案，一连续段小于答案



拿这个题目举例：

答案所有可能的取值可以分为两段

一般二分答案难就难在 `check()` 函数，所以很重要的一个点是一定要封装着当作一个子问题去理解

`check()` 的目的就是**检查答案应该在相较于条件的哪段**，显然我们可以根据：
$$
\sqrt[3]x \geq mid \Rightarrow x \geq mid \times mid \times mid
$$
得到 `check(mid)` 的判断表达式

注意这里因为**分界条件**比较简单，我们可以任意分段，只要能使得答案在两边就行了



### 整数二分答案

浮点二分答案简单，但是整数二分答案要考虑的就多了（待更新
