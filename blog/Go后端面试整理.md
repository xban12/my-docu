---
tags: [求职, AIChatHis]
---











# 八股





参考资料：

- gh: data-structures-questions

- 极客时间：go 面试题（local doc）



其余大程度是直接复制的GPT，没有自己内化过的

不一定都是重点，更像是一个学习记录。加粗过的可以算是重点

## Go





### 语法基础

#### 字符串



[The Go Programming Language Specification - The Go Programming Language](https://go.dev/ref/spec#String_types)

> 在 Go 语言中，字符串类型（`string`）是一个字节（byte）切片（`[]byte`）的不可变视图。这意味着字符串是由字节组成的，但是一旦创建，其内容不能被修改。在 Go 中，字符串是一个连续的字节序列，使用 UTF-8 编码表示 Unicode 字符。
>
> Go 语言的字符串类型和切片类型之间有一些相似之处。它们都是由连续的元素组成的，都具有长度（length）和容量（capacity）属性，而且都支持切片操作。然而，最大的区别是字符串是不可变的，而切片是可变的。
>
> Go 语言的字符串实现原理如下：
>
> 1. 字符串结构体：在 Go 的运行时，字符串是通过一个结构体来表示的，这个结构体包含一个指向底层字节数组的指针和字符串的长度。这使得字符串拥有常数时间的索引、切片和连接操作。
>
> 2. UTF-8 编码：Go 中的字符串采用 UTF-8 编码，这意味着每个 Unicode 字符可能由多个字节组成。由于字符串的长度是固定的，这就保证了索引和切片操作不会破坏合法的 Unicode 字符。
>
> 3. 不可变性：一旦一个字符串被创建，其内容是不可变的。如果需要修改字符串，可以将其转换为 `[]byte` 类型进行修改，然后再转回字符串类型。
>
> 4. 共享底层字节数组：由于字符串是不可变的，如果多个字符串共享相同的底层字节数组，它们将共享相同的内存。这可以有效地节省内存，并且使字符串的复制操作成为常量时间操作。
>
> 总结：Go 语言中的字符串是一个不可变的字节切片，使用 UTF-8 编码表示 Unicode 字符。它拥有常数时间的索引、切片和连接操作，且支持与切片类型之间的转换，以便进行必要的修改。由于字符串是不可变的，它们在共享底层字节数组时，可以实现高效的内存共享。



- rune 是 int32 的 alais，用来表示一个 Unicode 码点，即任意一个字符的编码数值，常用于转换成字符串



- 为何选择 `[]byte` 

字节类型相比 `int` 类型，单个字节直接表示一个字符，更符合字符串存储的逻辑



- 为什么 `&s[i]` 无效

> 在 Go 语言中，字符串是不可变的，也就是说一旦创建后，字符串的内容就不能被修改。为了保持字符串的不可变性，Go 禁止通过索引来直接访问或修改字符串中的单个元素。
>
> 所以，`&s[i]` 操作是非法的，因为它试图通过取字符串的索引来获取指向字符串中单个元素的指针，但这会破坏字符串的不可变性。
>
> 如果确实需要访问字符串中的单个元素，可以使用类型转换将字符串转换为字节切片（`[]byte`）或者 Unicode 编码（`[]rune`），然后通过切片索引来访问单个元素。但需要注意的是，这样做是以牺牲字符串的不可变性为代价的。
>
> 例如，我们可以这样访问字符串中的单个字节：
>
> ```go
> str := "Hello, 世界"
> byteSlice := []byte(str) // Convert string to []byte
> firstByte := byteSlice[0] // Access the first byte
> fmt.Printf("First byte: %c\n", firstByte) // Output: First byte: H
> ```
>
> 或者这样访问字符串中的单个 Unicode 字符（rune）：
>
> ```go
> str := "Hello, 世界"
> runeSlice := []rune(str) // Convert string to []rune
> firstRune := runeSlice[0] // Access the first rune
> fmt.Printf("First rune: %c\n", firstRune) // Output: First rune: H
> ```
>
> 但请注意，当使用上述方法访问字符串的单个元素时，可能会遇到多字节字符的问题，因为 Unicode 字符可能由多个字节组成。如果不对字符边界进行正确处理，可能会得到错误的结果。因此，在访问字符串的单个元素时，需要格外小心以避免出现错误。



- 字符串修改操作的复杂度？

所有变化的操作底层都是通过先转换成 `[]byte` 数组，然后再创建新的字符串进行赋值实现的



- 设计成不可变的好处

> 将字符串设计成不可变的有许多好处：
>
> 1. 线程安全：不可变字符串可以在多线程环境中使用而不需要额外的同步机制，因为不会有多个线程同时修改同一个字符串对象。
>
> 2. 简化并发编程：由于字符串不可变，当你传递字符串给其他函数时，你可以确保在函数内部不会被修改，从而简化了并发编程的复杂性。
>
> 3. 安全性：不可变字符串避免了许多常见的字符串操作中的错误，例如缓冲区溢出和无效的字符串索引。
>
> 4. 共享和重用：由于字符串不可变，多个字符串可以共享底层字节数组，从而节省内存并提高性能。在许多编程语言中，字符串字面值通常是不可变的，这使得多个字符串字面值可以共享同一份内存。
>
> 5. 效率：不可变字符串允许编译器执行更多的优化，因为它可以确保在不同的上下文中使用相同的字符串时不会发生意外的修改。
>
> 6. 安全传递：当你将不可变字符串传递给其他函数时，你可以确保它在函数内部不会被修改，从而避免不必要的副作用。
>
> 7. 缓存和哈希：由于字符串不可变，可以在哈希表等数据结构中使用字符串作为键，而不用担心键在存储期间发生变化。
>
> 总的来说，将字符串设计成不可变的是一种良好的软件设计选择，它提高了程序的健壮性、安全性和效率，并简化了并发编程。因此，在许多编程语言中，字符串被设计为不可变类型。





#### 切片

> 在 Go 语言中，数组和切片是两种不同的数据类型，并且它们有明显的区别。
>
> 1. 数组（Array）：
>    - 数组是一种固定长度的数据结构，元素的类型和数量都在创建时确定，并且在整个生命周期中保持不变。
>    - 数组的长度是类型的一部分，因此具有不同长度的数组是不同的类型。
>    - 数组的长度可以通过 `len()` 函数获取。
>    - 数组的声明方式为 `var arr [length]Type`，其中 `length` 表示数组的长度，`Type` 表示元素的类型。
>
> 2. 切片（Slice）：
>    - 切片是一个动态可变长度的序列，它是基于数组构建的一种抽象。
>    - 切片提供了对底层数组的动态操作，可以根据需要自动调整长度。
>    - 切片不需要指定长度，可以根据实际情况进行自动扩容和缩减。
>    - 切片的声明方式为 `var slice []Type`。
>
> 判断一个变量是数组还是切片可以通过以下方法：
>
> 1. 通过长度判断：
>    - 如果变量的长度是固定的，那么它是一个数组。
>    - 如果变量的长度可以动态变化，那么它是一个切片。
>
> 2. 通过类型判断：
>    - 如果变量的类型是 `[length]Type`，那么它是一个数组。
>    - 如果变量的类型是 `[]Type`，那么它是一个切片。
>
> 示例代码：
>
> ```go
> package main
> 
> import "fmt"
> 
> func main() {
> 	// 数组示例
> 	arr := [3]int{1, 2, 3}
> 	fmt.Println("数组:", arr, "长度:", len(arr))
> 
> 	// 切片示例
> 	slice := []int{4, 5, 6}
> 	fmt.Println("切片:", slice, "长度:", len(slice))
> }
> ```
>
> 输出结果：
>
> ```
> 数组: [1 2 3] 长度: 3
> 切片: [4 5 6] 长度: 3
> ```
>
> 通过观察长度和类型，我们可以确定一个变量是数组还是切片。数组的长度是固定的，而切片的长度是可变的。此外，可以通过变量的类型来进一步确认是数组还是切片。

- 数组也可以用“切片语法”
- 切片本质上是对数组的引用



#### Context



用来中断协程

```go
ctx, cancel := context.WithCancel(context.Background())

// 启动协程，传入上下文
go doWork(ctx)

// 运行一段时间后取消协程
time.Sleep(5 * time.Second)
cancel()
```





#### Interface





#### 杂



##### 指针

- go 指针支持哪些操作？
  - 而在 Go 语言中，指针不支持算术运算，不能直接修改指针的值来访问不同位置的内存。



- go里面也有函数传值和传指针的区别
  - 比如说 wg 这种结构体一般就是传值，要操作的话得注意穿指针



- new操作符返回指针



##### 平行赋值

- 平行赋值的底层实现顺序是，先完整计算右侧所有表达式的值，然后再从左到右进行逐个平行赋值。可以直接理解为并行的，是并发安全的。





##### 空结构体



set 实现

```go
func main() {
    // 创建一个整数集合
    intSet := make(map[int]struct{})

    // 添加元素到集合
    intSet[1] = struct{}{}
    intSet[2] = struct{}{}
    intSet[3] = struct{}{}

    // 检查元素是否存在于集合中
    if _, exists := intSet[2]; exists {
        fmt.Println("元素 2 存在于集合中")
    }

    // 删除元素
    delete(intSet, 2)

    // 遍历整数集合
    fmt.Println("集合中的元素：")
    for num := range intSet {
        fmt.Println(num)
    }
}

```







### 协程（并发特性）



#### GMP 模型

[Golang GMP 原理](https://mp.weixin.qq.com/s/jIWe3nMP6yiuXeBQgmePDg)



gmp = goroutine + machine + processor （+ 一套有机组合的机制）

- g 是 goroutine

  - go优化过的协程
    - 相比线程来说弱内核以来，更轻量级
    - 相比协程来说不依赖线程，可以并行，可以通过
  - 是基于 GMP 模型实现的
    - 和 p 绑定
    - 有自己的运行栈、状态、以及执行的任务函数（用户通过 go func 指定）；

- p 即 processor

  - 是 golang 中的调度器，GMP 中枢
    - 是 g 的 cpu
    - 是 m 的运行代理

  - 数量决定了最大并行数量，和实际 CPU 核数对应

- m 即 machine是 golang 中对线程的抽象

  - 绑定 p，实现代理，跨 m 执行

  

  

  

![](https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZv7BArqKhicntmW5bZrgickiagmsETWQlduKI8iaXiaPbMkDpB96wbe6H4tTdOSQYKcicw4S95ItS8YcWuQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)





模型运作基本机制

- MP 绑定
- 三类队列
  - 加锁情况
  - M 执行顺序
- work-stealing
  - 轻锁
  - 用于平衡负载



g 的生命周期

![](https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZv7BArqKhicntmW5bZrgickiag3yFaINywBYSVThjh6KZCiatwUgylmKOIdWRegKeakPojNc0lYRkVzuQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



数据结构

- g
  - 一个指向 M 的指针
  - `gobuf` ，实际 CPU 执行指令相关的指针
  - 生命周期
- m
  - `g0` 负责调度的协程，1:1
  - `tls` 线程本地存储
- p
  - 本地 (goroutine )队列
  - 指向下一个 gr 的指针



实际调度要点

- `g0` 和其他 g 的切换
- 不同的调度类型
- 宏观调度流程





#### Sync包



`sync.Pool`







### Channel

> 其实也应该是并发里的内容，单独抽出来





#### close

(range)

- `close` 是 channel 的一个一次性操作，不可逆
- range 也是唯一再 close 状态下可用的，作用是将关闭信道的内容逐个取出

- 关闭状态下读入不会被阻塞，写入则会触发 panic



channel判断关闭是否协程安全？



close(ch)和读通道是否冲突？



#### select

- 哪个 case 的信道通就执行哪里，如果都准备好了就是随机

- `default` 分支很重要，是所有分支都阻塞的时候执行的分支





#### 缓冲

有缓冲的Channel和无缓冲的Channel

> 在Go语言中，有缓冲的Channel和无缓冲的Channel是两种不同类型的Channel。它们之间的主要区别在于，**无缓冲的Channel是同步的，而有缓冲的Channel是非同步的**。
>
> 无缓冲的Channel在消息发送时需要接收者就绪。当一个协程向无缓冲的Channel发送消息时，它会阻塞直到另一个协程从该Channel接收消息。这种特性使得无缓冲的Channel可以用来在协程之间进行同步¹。
>
> 有缓冲的Channel则不要求发送和接收操作同步。它内部有一个缓冲区，可以存储多个消息。当一个协程向有缓冲的Channel发送消息时，只要缓冲区未满，它就不会阻塞。同样地，当一个协程从有缓冲的Channel接收消息时，只要缓冲区不为空，它也不会阻塞³。
>
> 下面是一个简单的例子来说明两者之间的区别：
>
> ```go
> package main
> 
> import (
> 	"fmt"
> 	"time"
> )
> 
> func main() {
> 	// 无缓冲的 Channel
> 	unbuffered := make(chan int)
> 	go func() {
> 		fmt.Println("Sending to unbuffered channel")
> 		unbuffered <- 1
> 		fmt.Println("Sent to unbuffered channel")
> 	}()
> 
> 	time.Sleep(time.Second)
> 	fmt.Println("Receiving from unbuffered channel")
> 	<-unbuffered
> 	fmt.Println("Received from unbuffered channel")
> 
> 	// 有缓冲的 Channel
> 	buffered := make(chan int, 1)
> 	go func() {
> 		fmt.Println("Sending to buffered channel")
> 		buffered <- 1
> 		fmt.Println("Sent to buffered channel")
> 	}()
> 
> 	time.Sleep(time.Second)
> 	fmt.Println("Receiving from buffered channel")
> 	<-buffered
> 	fmt.Println("Received from buffered channel")
> }
> ```
>
> 在这个例子中，我们创建了一个无缓冲的Channel和一个有缓冲的Channel。对于无缓冲的Channel，发送操作会阻塞直到接收操作发生。而对于有缓冲的Channel，发送操作不会阻塞，因为它内部有一个大小为1的缓冲区。
>
> 运行这段代码，你会看到类似下面这样的输出：
>
> 
>
> ```
> Sending to unbuffered channel
> Receiving from unbuffered channel
> Received from unbuffered channel
> Sent to unbuffered channel
> Sending to buffered channel
> Sent to buffered channel
> Receiving from buffered channel
> Received from buffered channel
> ```
>
> 可以看到，在无缓冲的Channel中，发送操作会阻塞直到接收操作发生。而在有缓冲的Channel中，发送操作不会阻塞。
>



- 为什么对于无缓冲的 Channel，只有在协程中发送、主进程中接受才能正常，反之则死锁。

  暂时考虑为，主线程的接收是一定准备好的，协程则不一定，这就是go的设计



#### 方向

> 在 Go 语言中，channel 是一种用于在 Goroutine 之间进行通信的特殊类型。Channel 有方向之分，可以分为单向 channel 和双向 channel。
>
> 1. 单向 channel（Unidirectional Channel）：单向 channel 只允许一种方向的数据传递，即只能用于发送或接收数据。在定义单向 channel 时，需要使用 `<-` 运算符来指定其方向。
>
> - 发送通道（Send-only Channel）：`chan<- T` 表示只允许向 channel 发送类型为 T 的数据，不能从 channel 中接收数据。
> - 接收通道（Receive-only Channel）：`<-chan T` 表示只允许从 channel 接收类型为 T 的数据，不能向 channel 发送数据。
>
> 例如：
>
> ```go
> func sender(ch chan<- int) {
>     ch <- 10
> }
> 
> func receiver(ch <-chan int) {
>     value := <-ch
>     fmt.Println("Received:", value)
> }
> ```
>
> 2. 双向 channel（Bidirectional Channel）：双向 channel 不做方向限制，可以用于发送和接收数据。在定义 channel 时，不加任何方向限定即为双向 channel。
>
> 例如：
>
> ```go
> func worker(ch chan int) {
>     // Send data
>     ch <- 42
> 
>     // Receive data
>     value := <-ch
>     fmt.Println("Received:", value)
> }
> ```
>
> 需要注意的是，单向 channel 可以隐式地转换为双向 channel，反之则不行。也就是说，一个 `chan<- T` 类型的变量可以隐式转换为 `chan T` 类型，而 `chan T` 类型的变量不能隐式转换为 `chan<- T` 类型。
>
> ```go
> func main() {
>     ch1 := make(chan int)
>     ch2 := make(chan<- int)
> 
>     // ch1 is a bidirectional channel
>     ch1 = ch2
> 
>     // Error: Cannot use ch1 (type chan int) as type chan<- int in assignment
>     ch2 = ch1
> }
> ```
>
> 总结：Go 语言中的 channel 可以分为单向 channel 和双向 channel。单向 channel 只能用于发送或接收数据，而双向 channel 不做限制，可以同时发送和接收数据。在定义 channel 时，使用 `<-` 运算符可以指定其方向。



### 垃圾回收 GC

主要是并发三色标记法+混合写屏障机制

- 前者是迪杰斯特拉提出的一种算法，是标记清扫算法的一个演进，将根变量置黑、指向的变量置灰，然后去扫描，白色的就是可能的垃圾

- 但是这种方案不能确保完美标记，混合写屏障机制就是解决这个问题的。

  混合写屏障机制通过在编译器层面对对象的访问进行记录，以及在运行时对访问操作进行拦截和处理，来保证并发操作的正确性。这样，垃圾收集器可以在并发执行的情况下，保证对对象的访问操作不会导致垃圾回收的错误。







### 内存模型



在 Go 语言的内存模型中，栈区和堆区分别负责以下内容：

> 1. **栈区（Stack）**：
>    - 栈是用于存储局部变量和函数调用信息的一块内存区域。
>    - 每个 Goroutine 都有自己的栈空间。栈空间的大小默认为 2KB，可以通过 GOMAXPROCS 环境变量调整。
>    - 栈的分配和释放是自动进行的，由编译器在编译时决定。当 Goroutine 进入一个函数时，栈会自动增长以存储局部变量和函数调用的信息；当 Goroutine 离开函数时，栈会自动收缩并释放内存。
>    - 栈的分配和释放是非常高效的，因为它是由编译器自动管理的，不需要垃圾回收参与。
>
> 2. **堆区（Heap）**：
>    - 堆是用于存储动态分配的内存的一块内存区域。
>    - 在堆上分配的内存需要手动进行释放。在 Go 语言中，由垃圾回收器负责回收不再使用的堆内存。
>    - 在 Go 中，通过 `new` 或 `make` 函数分配的对象都存储在堆上。例如，使用 `new` 函数创建的对象是通过指针返回的，而指向的内存块在堆上分配；使用 `make` 函数创建的 slice、map 和 channel 也是在堆上分配内存的。
>
> 总结起来，栈区主要负责存储局部变量和函数调用信息，栈的分配和释放是自动进行的；而堆区主要负责存储动态分配的内存，需要手动进行内存的分配和释放。Go 语言的内存模型通过栈和堆的合理管理，实现了高效的内存分配和回收，从而保证了程序的性能和稳定性。





![](https://mmbiz.qpic.cn/mmbiz_png/3ic3aBqT2ibZuXibKvib2fj2vlIia93waBCNwkd8rJZ9b0h745aibfNReUePg2bqzT4ibrB6rrxzlzf6fMZnXib87O5o4w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- 使用缓存用空间换时间
- 多级缓存 为了减少 mhead 的重锁而设计的
  - mheap
  - mcenter 不同规格的缓存分类，细琐
    - page 借鉴 OS 的思想，减少内存碎片
      - span
  - mcache 无锁







### 杂

- Go 的数组类型取值范围和体系架构是有关的
- 





## Redis



### 基础



做过哪些应用？

1. 作为连续签到的一个缓存，设置过期时间
2. 游戏的实时排行榜更新
3. 
4. 消息队列、list异步
5. 限速器
6. 利用集合的一些操作来维护好友关系



和 MySQL 如何配合？

- 读的时候优先读 Redis，再读 MySQL

- 写的时候先写到 MySQL 里，再通过【Binlog监听】来写入 Redis

​	

### 数据结构



1、String的实现 (SDS，动态字符串)

- 大致原理：用二进制的方式存一个数组，SDS初始化在中间（靠右？）的某个位置，左边存储元信息（长度，分配，标志位（类型))，右边存储缓冲的值

- 特点

  - SDS 所有的 API 都是用二进制的方式来处理的（所以可以存视频

  - O(1) 获取字符串长度

  - 很快读写、节省空间、很快反应

    

  



### 持久化



### 高可用

主从复制

- 从服务器只读，由主服务器发送命令写
- 异步进行，无法保证数据一致性



哨兵模式

- 就是监控故障，用于切换的



### 缓存





### 其他

#### 分布式锁

- [Redis 实现分布式锁](https://xiaolincoding.com/redis/base/redis_interview.html#%E5%A6%82%E4%BD%95%E7%94%A8-redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84)



## MySQL



### SQL



#### JOIN

- 默认是内 join
- 左右联表查询的意思就是左右表所有记录都保持好，如果右表不匹配就用 NULL 填充

- 看看这个图[MySQL的join用法_mysql中join的用法_huatian5的博客-CSDN博客](https://blog.csdn.net/huatian5/article/details/80854455)



### 基础

#### 概念

- 主键：唯一区分一条记录的一个键
  - 隐式主键：当创建的时候没有指定主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键，第一列有 `UNIQUE` 的约束的时候，就会在列上创建，这时的主键就是隐式的。（不确定，文档没找到，有一种说法是所有列都找不到，底层使用的rowid才是隐式主键，特点是用户操作不了。没有实际场景不用想得太深了）
- 外键：这个键在另一个表中是主键，常用于联表查询
- 以上二者共同构成了关系型数据库的关系模型



#### 语句执行

[执行一条 select 语句，期间发生了什么？ | 小林coding](https://xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)

- 分两层
  - Server 存，连接和主要服务
  - 存储引擎，由引擎直接操作数据库
- 执行大致步骤
  1. 连接器和客户端通信
  2. 查缓存
  3. 解析器
  4. 执行器
  5. 调用存储引擎的接口进行查询



> MySQL中一条UPDATE语句的执行过程可以简要概括为以下几个步骤：
>
> 1. **解析器阶段**：MySQL首先对UPDATE语句进行解析，识别UPDATE关键字、要更新的表名、SET子句中的更新字段和值、WHERE子句中的更新条件等。
>
> 2. **查询优化器阶段**：在解析器解析完UPDATE语句后，MySQL会进入查询优化器阶段。优化器会根据表的索引、统计信息等选择最优的执行计划。
>
> 3. **执行计划阶段**：在选择好最优执行计划后，MySQL会根据执行计划执行UPDATE操作。根据WHERE子句中的条件，找到要更新的记录。
>
> 4. **行锁定**：在找到要更新的记录后，MySQL会对这些记录进行行级锁定，以防止其他事务同时修改同一行记录，保证数据的一致性和隔离性。
>
> 5. **日志写入**：在更新操作之前，MySQL会将原始数据（或者Undo日志）记录在事务日志中，以便在发生回滚操作时恢复数据。
>
> 6. **执行更新**：MySQL根据UPDATE语句中的SET子句，将新的数据写入到表中。
>
> 7. **更新索引**：如果更新操作涉及到索引字段，MySQL会更新相应的索引以反映数据的变化，确保索引的准确性。
>
> 8. **事务提交**：在UPDATE操作完成后，MySQL会等待事务的提交。如果UPDATE语句在事务中，将等待事务提交后才会生效。
>
> 值得注意的是，UPDATE语句的执行过程可能会受到表的大小、索引情况、并发访问等因素的影响。优化数据库设计、索引的使用以及合理的事务管理，都有助于提高UPDATE语句的执行效率和数据库的性能。





### 索引



#### 认识



索引分类

- 分类依据
  按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。

  按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。

  按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。

  按「字段个数」分类：**单列索引、联合索引**。

- 聚簇索引，约等于主键索引，表示将磁盘上的数据直接聚集来进行一种索引的意思。因为只能聚簇索引一次，所以一个表中的其他索引都是非聚簇索引，即辅助索引
- 二者都默认使用 B+树索引（辅助索引是利用主键指针，而聚簇是直接物理索引，zhi'jie）

> 当你在数据库表上创建聚簇索引时，它会根据索引的键值对表中的记录进行排序和物理存储。换句话说，聚簇索引决定了数据在磁盘上的物理组织方式。通常情况下，一个表只能有一个聚簇索引。
>
> 举个例子，假设你有一个名为Customers的表，其中包含客户的信息，包括CustomerID、Name、Email等列。如果你在CustomerID列上创建了聚簇索引，那么数据库会根据CustomerID的值来对表中的记录进行排序和存储，使得具有相似CustomerID值的记录在物理上相邻存储。这意味着当你根据CustomerID进行查询时，数据库可以更快地访问到相关记录，因为它们在物理上就在一起。
>
> 与聚簇索引相对应的是非聚簇索引（或称为辅助索引或次要索引）。非聚簇索引在创建时并不会改变数据在磁盘上的物理存储方式，而是在索引中存储键值和对应的行指针。这样的索引可以帮助加快基于索引列的搜索，但是在执行范围查询时可能效率较低，因为它需要通过索引查找到行指针，然后再去访问实际的数据行。
>
> 以我们之前的例子来说，如果你在Name列上创建了一个非聚簇索引，那么索引会存储客户姓名的值和对应的行指针。当你根据客户姓名进行搜索时，数据库会首先查找索引，获取到相应的行指针，然后再去找到实际的数据行。
>
> 总结一下：
> - 聚簇索引决定了数据在磁盘上的物理存储方式，并根据索引的键值对记录进行排序。
> - 聚簇索引在查找特定键值的记录时效率较高，但范围查询可能效率较低。
> - 非聚簇索引存储键值和对应的行指针，提供了更快的搜索速度，但在需要访问实际数据行时会有额外的查询开销。
>
> 根据具体的数据和查询需求，你可以选择在表上创建聚簇索引或非聚簇索引，以提高数据库的查询性能。
>



#### 原理

是如何使用 B+ 树存储的

- 理解好 B树，理解好 B+树
- 这个基础上，叶子节点改动
  - 双向链表
  - 存多个记录





> MySQL使用B+树作为索引结构有以下几个重要原因：
>
> 1. **高效的查找操作**：B+树是一种平衡树，其高度相对较低，可以在O(log N)时间内完成查找操作。这使得在大规模数据量下，查找速度非常高效。
>
> 2. **有序性**：B+树的特性保证了其在范围查询和排序操作上的高效性。在数据库中，经常需要对数据进行排序和范围查询，B+树天生适合这些操作。
>
> 3. **磁盘IO优化**：B+树的节点是按照顺序存储的，这使得数据库在进行磁盘IO操作时，可以较少磁盘寻道的次数，从而提高IO效率。
>
> 4. **支持高效的插入和删除操作**：B+树的平衡特性保证了在插入和删除数据时，树的高度始终保持较低，维持了较高的查询效率。
>
> MySQL中的哈希索引是针对Memory引擎的表使用的，不适用于InnoDB引擎的表。MySQL中的主要索引类型是B+树索引，包括聚集索引和非聚集索引。聚集索引是数据行的物理排序，而非聚集索引则是指向数据行的指针。
>
> 索引的过程可以简单地描述为：
>
> 1. 查询数据：当执行SELECT语句时，MySQL首先会查找相关的索引来定位数据行。
>
> 2. 确定索引类型：根据查询条件和表的索引类型（聚集索引或非聚集索引），MySQL决定使用哪种索引。
>
> 3. 找到数据行：通过索引定位到相应的数据行，然后获取所需的数据。
>
> 4. 范围查询：如果查询条件是范围查询（例如，WHERE语句中使用了BETWEEN、IN等操作符），B+树索引可以快速找到满足条件的数据范围。
>
> 5. 排序：如果需要对结果进行排序，B+树索引可以快速返回按照索引列排序的结果。
>
> 需要注意的是，虽然哈希索引对于单个查询的查找速度很快，但它不支持范围查询、排序操作和模糊查询。因此，在数据库中通常会根据具体的使用场景选择合适的索引类型，B+树索引是MySQL中最常用且最通用的索引类型。



- 平衡、多叉：高度低，减少IO，查找效率高	



#### 使用

1、**不同 count 方式的性能比较？（一般会结合项目，问你是否测试过其性能）**

[count(*) 和 count(1) 有什么区别？哪个性能最好？](https://xiaolincoding.com/mysql/index/count.html)

- 结论是 star其实是0 = 1 > 主键 > 其他键
  - 1是最快的，就是直接用主键遍历树且不用读内容
  - star 不是全部，而是0，和1是一样的，永远不是null，然后还有优化：如果有多个二级索引，会选key最短的
  - 主键遍历有二级索引也会有限二级索引
  - 其他键就是只能逐个遍历了，因为没有suo'yin







## 计网





### 基础





1、TCP/IP 网络模型有哪几层？介绍说明

整体上来说，我的理解上，不同的层实际上就是不同的抽象程度，这样可以方便当前层的设计只需要用更底层的接口来实现，然后来专注当前层的实现即可。

1. 应用层

   1. 唯一用户态的层
   2. HTTP

2. 传输层

   1. 主要涉及 TCP 和 UDP
   2. 传输层和应用层是我们在进行 WEB 编程的时候常常需要涉及的抽象层

3. 网络层

   1. IP 在这层作用
      1. 用子网掩码算出主机号和网络号来定位
   2. 和传输层的区别大致在于，他是负责路由的，可以想象成高速公路，而我们的传输只负责接受数据然后用普通的车子进行简单搬运

4. 网络接口层、（物理层

   1. 以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。
   2. IP + MAC 才能在局域以太网中定位到设备

   

> TCP/IP 网络模型由四层组成，每一层都有不同的功能和作用。以下是每一层的定义、作用和具体例子：
>
> 1. **应用层（Application Layer）**：
>    - 定义：应用层是网络模型的顶层，负责处理用户与应用程序之间的通信。
>    - 作用：提供各种应用程序之间的通信服务和协议，如 HTTP、FTP、SMTP 等。
>    - 例子：使用 Web 浏览器通过 HTTP 协议访问网页、使用电子邮件客户端通过 SMTP 协议发送电子邮件。
>
> 2. **传输层（Transport Layer）**：
>    - 定义：传输层负责在网络中的不同主机之间提供端到端的数据传输。
>    - 作用：确保可靠的数据传输、错误检测和恢复，以及流量控制。
>    - 例子：使用 TCP 协议进行可靠的数据传输，如下载文件或通过套接字进行实时通信。
>
> 3. **网络层（Network Layer）**：
>    - 定义：网络层负责处理主机之间的数据包传输和路由选择。
>    - 作用：提供主机之间的逻辑通信，将数据包从源主机传送到目标主机。
>    - 例子：使用 IP 协议进行数据包的路由和转发，确保数据包从源主机正确地传输到目标主机。
>
> 4. **链路层（Link Layer）**：
>    - 定义：链路层负责在直接相连的两个节点之间传送数据帧。
>    - 作用：处理与物理介质的通信细节，包括物理地址寻址、错误检测和纠正。
>    - 例子：使用以太网协议（Ethernet）将数据帧从一个网络接口传输到另一个网络接口。
>
> 另一个同时经过所有层的传输例子是在浏览器中访问一个远程网站。以下是该例子中每层的具体作用：
>
> 1. 应用层：浏览器使用 HTTP 协议向远程服务器发送请求，并接收响应。
> 2. 传输层：浏览器将 HTTP 请求封装为 TCP 报文段，并将其发送到远程服务器的 IP 地址。
> 3. 网络层：浏览器将 TCP 报文段封装为 IP 数据包，并通过路由选择将数据包发送到远程服务器。
> 4. 链路层：浏览器将 IP 数据包封装为以太网帧，并通过物理介质（如以太网）将帧发送到网络中。
> 5. 目标主机上的网络接口接收到以太网帧后，依次经过链路层、网络层和传输层进行解封和处理，最终将 HTTP 响应传递给远程服务器上的应用层。
>
> 通过以上的例子，你可以看到数据在经过每一层时是如何被封装、处理和传输的，直到达到目标主机并被解封。这种分层模型使得不同层之间的功能和责任清晰，并且提供了灵活性和可扩展性。



2、**浏览器键入一个URL的过程发生了什么（后端视角**

1. HTTP 协议，主要是解析需要资源，确定方法，提供报文进行传输
2. DNS，先查缓存，然后 HOSTS ，最后才是我们本地 + 多级域名 DNS 问路
3. 找到目的地以后，还是要通过协议栈来封装我们的数据包
   1. TCP 来三次握手，建立连接，确定有能够在进行连接的能力
   2. 传输的时候 TCP 需要配合 IP（网际协议） 来确定传输位置，封装成网络包
   3. 然后经过 MAC 层，主要是 ARP 协议，再加上 MAC 头，以此来定位以太网中的物理机
4. 然后以此经过、网卡、交换机、路由器到达客户端，然后再一层层剥开封装



> 当我们在浏览器中输入一个网址，大致会经历如下几个步骤：解析网址、连接管理、处理报文、处理请求、处理响应。下面我会从网址的解析开始，逐步串起整个过程。
>
> 浏览器首先会解析网址，获取到对应请求的IP地址和端口号，用于后续构建报文。由于IP地址太长不方便记忆，我们可能会使用域名来代替。如果使用域名，就需要根据域名解析出IP地址。解析域名的过程是：先挨次从浏览器缓存、本地缓存、本地DNS服务器缓存中查找IP地址，如果都找不到，就会向根DNS服务器发起请求，然后根据域名等级，挨级找到能够根据此域名映射出IP地址的权威DNS服务器，并将结果返回给本地DNS服务器，并进行缓存。获取到IP地址等信息后，就可以将请求委托给协议栈了。
>
> 如果发现请求的协议底层是基于TCP的（例如HTTP协议），为了能够确保自己和目标能够进行通信，协议栈首先会用解析出来的信息，去检查与目标端口是否有已建立的可复用的TCP连接。如果没有，则会先通过三次握手，为双方建立好TCP连接。如果是基于UDP的，则不需要对连接进行管理。当确认双方能够通信的时候，就可以开始处理报文了。
>
> 基于已有的IP地址、端口号、请求数据、TCP通信等信息，先构建出HTTP Message，其中主要包含请求行、请求头和请求体（如果有）三部分。为了防止数据丢失重传时数据过大，HTTP Message 在进入传输层时，可能会被拆分成很多个数据段。进入传输层后，会为报文添加上TCP头部信息。除了包含源端口和目标端口外，还有用于流量控制、拥塞控制、重传机制相关的字段。然后将报文传递给网络层，主要需要添加上源IP地址和目标IP地址等信息变成数据包。然后将数据包传递给网络接口层，通过IP寻找到下一站MAC地址，将数据封装成以太网帧后传递给网卡。网卡将这一系列帧的比特流转换成信号，并通过路由器交换机等设备，将信号逐步传递到目标计算机的网卡中。
>
> 信号到达目标计算机后，又会通过校验、拆解、组装报文等一系列的操作，最终服务器会在应用层接收到来自客户端应用层发送的HTTP Message。再通过解析报文信息，处理客户端请求等一系列操作，并得到响应报文。再将这一段响应的HTTP Message经过一系列包装、传输、拆包等操作，从服务器的应用层发送到客户端的应用层。客户端再根据响应的HTTP Message做出下一步操作。
>
> 这就是在客户端浏览器键入一个URL的整个过程。为了说清楚整个过程，我省略了许多应用层、传输层的细节。其中还有很多知识值得深入学习。







### HTTP

1. **一个 HTTP 请求的过程 （建立连接的过程，释放连接的过程，为什么要Time-Wait这个阶段）**
2. HTTP 演变说明
   1. 1.0 -> 1.1 从无连接模型演变成一种可以并行，可以建立一次长的持续链接
   2. 1.0 -> 2.0
   
      > HTTP/2 是对 HTTP/1.1 的改进和优化，主要包括以下方面的改进：
      >
      > 1. **多路复用（Multiplexing）**：HTTP/2 引入了多路复用技术，允许在单个 TCP 连接上同时发送多个请求和接收多个响应。这样可以避免 HTTP/1.1 的队头阻塞问题，提高请求和响应的并发性能。
      >
      > 2. **二进制传输**：HTTP/2 将请求和响应数据分割为二进制格式，并使用帧和流的概念进行传输。相比于 HTTP/1.1 的文本传输，二进制传输更高效，减少了传输数据的大小，节省了带宽。
      >
      > 3. **首部压缩（Header Compression）**：HTTP/2 使用 HPACK 压缩算法对请求和响应头进行压缩，减少了重复的首部字段，从而降低了传输的开销。
      >
      > 4. **服务器推送（Server Push）**：HTTP/2 支持服务器推送技术，允许服务器在客户端请求之前主动推送相关的资源。这样可以减少客户端的请求次数，提高页面加载速度。
      >
      > 5. **优先级（Priority）**：HTTP/2 支持请求和响应的优先级设置，可以根据资源的重要性来优先处理，提高了网络资源利用率。
      >
      > 6. **流控制（Flow Control）**：HTTP/2 引入了流控制机制，允许接收方根据自身处理能力来控制接收数据的速率，防止过载。
      >
      > 具体实现上，HTTP/2 的优化是通过协议的改进来实现的。HTTP/2 在应用层与传输层之间使用二进制帧和流来组织数据，使用多路复用技术在单个 TCP 连接上处理多个请求和响应。通过对首部的压缩和数据的二进制传输，减少了数据传输的大小，提高了网络传输效率。服务器推送和优先级设置也是通过特定的帧和流来实现的。
      >
      > 由于 HTTP/2 是在应用层之上的传输层协议，因此在使用 HTTP/2 时，不需要修改现有的应用程序代码。只需要在服务器和客户端的网络配置中启用 HTTP/2 支持即可。HTTP/2 相对于 HTTP/1.1 在性能和效率上有显著的提升，尤其在高并发和大量资源加载的情况下表现更加优越。
   
   3. 2.0 -> 3.0 主要是 QUIC 协议，UDP 的一个改进，解决了 TCP 的诸如丢包成团的一些问题



5、HTTP 连接超时可能出现在哪些环节？

1. DNS 解析：在建立连接之前，客户端需要将服务器的域名解析为 IP 地址。如果 DNS 解析过程超时或出现问题，就无法建立连接。
2. 网络延迟：在网络通信中，可能由于网络拥塞、高延迟等原因导致连接建立的过程超时。这可能是由于网络环境不稳定或服务器过载引起的。
3. 防火墙或代理设置：如果客户端或服务器端存在防火墙或代理，其配置可能会影响连接建立过程，例如配置了过于严格的规则或出现了配置错误。
4. 服务器负载：如果服务器负载过高，无法处理新的连接请求，就会导致连接超时。









### TCP





3、**UDP 和 TCP 的区别？各有什么应用场景？**

- 是否需要建立连接

- 服务对象、交互端点
- 是否会保证数据按序完整到达，【可靠性】
- 相关传输控制（拥塞、流量）
- 首部开销
- 分片方式（MSS，MTU）



> TCP（传输控制协议）和UDP（用户数据报协议）都是在网络通信中使用的传输层协议，用于在网络上可靠地传输数据。它们之间有以下区别：
>
> TCP（传输控制协议）：
>
> - 提供面向连接的、可靠的数据传输。
> - 建立连接、数据传输和断开连接的过程中进行可靠性检验和错误修复。
> - 使用滑动窗口、序列号和确认应答机制来确保数据的可靠性和有序性。
> - 数据包按顺序到达，无丢失、重复或错误。
> - 适用于需要可靠传输、顺序传递和错误检测与恢复的应用。
>
> UDP（用户数据报协议）：
>
> - 提供无连接的、不可靠的数据传输。
> - 不进行连接建立和断开过程，直接发送数据报。
> - 不进行数据包的确认和重传，也不保证数据包的顺序性。
> - 适用于实时性要求高、数据丢失可容忍的应用。
> - 更加轻量级，传输效率较高。



4、**说明 TCP 的握手和挥手**



三次握手

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

- 注意几个状态，先是服务端主动开始监听，然后是客户端、分别处于同步发送接收状态，最后建立链接
- 三个报文，其实变的东西，大概就是各一个序列号，然后标志位表示确定应答相关内容
- 第三次握手才包含应用层数据

- 握手的目的是确保双方有接收、发送的能力，是确保【可靠性】的一环
- 需要三次的原因是，我们可以得以用一个服务端中间态来阻止重复的历史连接



四次挥手

![](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

- 每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。
- 客户端发起断开请求，首先发出带 FIN 的报文，需要分别得到 一个 ACK 和 FIN 确认两次，最后等待时间结束
- 服务端的两次主要是确保完全关闭以后，然后我们在得到客户端最后一次确认后完全关闭
- 每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。
- FIN 表示不再发送数据，ACK 表示不再接受数据
- 但是在特定情况下，四次挥手是可以变成三次挥手的，具体情况可以看这篇：TCP 四次挥手，可以变成三次吗？



TIME_WAIT

- 2MSL：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。
- **原因**：
  - 防止历史连接中的数据，被后面相同四元组的连接错误的接收；
    - 因为序列号是不能判断先后的，等待时长可以等到自然消亡
  - 保证「被动关闭连接」的一方，能被正确的关闭；
    - 等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。



### IP

 	





## OS



### CPU





### 进程

1、进程和线程的区别，它们是如何进行通信的

区别

- 定义
- 切换开销
- 资源占用
- 并发性能

通信方式

- 进程
  - 管道
  - 共享内存
  - 消息队列
  - 套接字
- 线程
  - 共享内存
  - 信号量





什么是死锁，如何解决死锁

> 死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进²。死锁产生的原因有很多，如系统资源的竞争、进程推进顺序非法、信号量使用不当等等²。
>
> 关于死锁的避免主要是这几个方面：尽可能使用无锁编程，使用开放调用的编码设计；尽可能的缩小锁的范围，防止锁住的资源过多引发阻塞和饥饿；如果加锁的时候需要获取多个锁则应该正确的设计锁的顺序；使用定时锁，比如Lock中的tryLock()等³。
>
> 死锁解决的方法主要有以下三种：死锁防止、死锁避免、死锁检测和恢复。死锁防止是在程序运行之前防止发生死锁，它通过破坏死锁产生的四个条件中至少一项来实现。死锁避免是在程序运行时避免发生死锁。而死锁检测和恢复则是不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复
>
> 
>
> 避免死锁的一个著名算法是银行家算法（Banker's Algorithm），它是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的演算法³。
>
> 银行家算法的基本思想是：始终保持系统处于安全状态，当进程提出资源请求时，系统先进行预分配，再判断系统分配后是否仍然处于安全状态。如果仍然处于安全状态，就进行实际分配；如果处于不安全状态，则撤销预分配、拒绝该进程的资源请求¹。
>
> 下面是一个简单的使用案例：假设我们有一把蓝钥匙，可以打开一扇蓝色门；以及一把红钥匙，可以打开一扇红色门。两把钥匙被保存在一个皮箱里。同时我们定义六种行为：获取蓝钥匙，打开蓝色门，归还蓝钥匙，获取红钥匙，打开红色门，归还红钥匙。游戏规则是：一个人（线程）必须通过排列六种指令的顺序，打开两扇门，最后归还钥匙。如果某个线程取钥匙时发现钥匙已被另一个线程取走了，它会等着，等到另一个线程归还了钥匙之后再继续²。







### 杂



在设备管理中，引入缓冲区的主要原因可归结为以下几点：

1. 缓和 CPU 与 I/O 设备间速度不匹配的矛盾。例如，一个程序时而进行长时间的计算而没有输出，时而又阵发性把输出送到打印机。由于打印机的速度跟不上CPU，而使得CPU长时间的等待。如果设置了缓冲区，程序输出的数据先送到缓冲区暂存，然后由打印机慢慢的输出。这时，CPU 不必等待，可以继续执行程序。实现了 CPU 与 I/O 设备之间的并行工作¹。

2. 可以减少对CPU的中断频率，放宽对中断响应的时间限制。如果 I/O 操作每传送一个字节产生一次中断，那么设置了 n 个字节的缓冲区之后，则可以等到缓冲区满才产生中断，这样中断次数就减少到1/n，而且中断响应的时间也相应的放宽²。

3. 提高CPU和 I/O 设备之间的并行性。缓冲的引入可显著提高 IO 设备效率，使得CPU中断减少因而可以并行。





## 算法



### 排序



各种排序适合的使用场景：

- 插入排序适合大部分元素已经有序
- 动态排序，可以使用堆排序，修改复杂度低

- 大量数据使用归并排序，B+





### 数据结构



#### 复杂树结构

> 搜索树、AVL树、B树、红黑树和B+树都是常见的数据结构，用于在存储和检索数据时提供高效的访问方式。它们之间的关系如下：
>
> 1. 搜索树（Search Tree）：搜索树是一种树形数据结构，它具有有序的特性。搜索树中的每个节点都存储一个键值，并满足以下性质：对于任意节点，其左子树中的键值小于节点的键值，右子树中的键值大于节点的键值。搜索树提供了高效的搜索、插入和删除操作。
>
> 2. AVL树：AVL树是一种自平衡的二叉搜索树。它具有搜索树的性质，并且通过在插入或删除操作后执行旋转操作来保持树的平衡。AVL树的平衡因子（左子树高度减去右子树高度）的绝对值不超过1。AVL树的平衡性能较好，适用于频繁的插入和删除操作。
>
> 3. B树：B树是一种多叉搜索树，用于处理大量的数据和支持高效的磁盘访问。B树的特点是每个节点可以存储多个键值，节点中的键值按照顺序排列，并且每个节点都有固定的范围。B树通过调整树的高度和节点的分裂合并来保持平衡，以实现高效的数据检索。
>
> 4. 红黑树：红黑树是一种自平衡的二叉搜索树，它在AVL树的基础上进行了改进。红黑树通过引入额外的颜色属性（红色或黑色），并遵循一组规则来保持树的平衡。这些规则确保了红黑树的最长路径不超过最短路径的两倍，保持了树的相对平衡。红黑树在插入和删除时的平衡操作比AVL树更简单，适用于需要平衡和较快的插入删除操作的场景。
>
> 5. B+树：B+树是一种在B树的基础上进行了改进的多叉搜索树，主要应用于数据库和文件系统中。B+树与B树的主要区别在于，B+树的内部节点不存储具体的数据，只存储键值和指向子节点的指针，而数据都存储在叶子节点上形成一个有序链表。B+树的叶子节点通过指针连接，使得范围查询和顺序遍历更加高效。
>
> 总结：
> - 搜索树是一种树形数据结构，提供有序的存储和检索方式。
> - AVL树、B树、红黑树和B+树都是在搜索树的基础上进行了改进，用于提供高效的数据访问和保持平衡性能。
> - AVL树和红黑树是平衡二叉搜索树，适用于频繁的插入和删除操作。
> - B树和B+树是多叉搜索树，主要用于处理大量数据和高效的磁盘访问。
>
> 这些数据结构在不同的场景和需求下具有不同的优势和特性。根据具体的应用需求，选择适合的数据结构可以提高数据的存储和检索效率。
>



## 杂



1、面向对象的概念和特点?封装、继承和多态是什么?

- 定义一种将数据和方法组合成对象进行组织的编程范式
- 特点
  - 封装：封装数据和方法，隐藏内部实现，暴露接口供调用
  - 继承：派生，代码的重用和扩展
  - **多态**：不同对象对同一操作的的不同的实现方式，可以通过相同的接口进行调用。比如说运算符重载，和泛型的语言特性

> 面向对象编程（Object-Oriented Programming，OOP）是一种编程范式，它将程序中的数据和操作数据的方法组织在一起，以对象的形式进行描述和处理。面向对象的编程主要包括以下几个概念和特点：
>
> 1. 对象（Object）：对象是面向对象编程的基本单位，它是对现实世界中的事物或概念的抽象和实体化。对象具有属性（数据）和方法（操作），它们封装在一起形成一个独立的实体。
>
> 2. 类（Class）：类是对象的模板或蓝图，它定义了对象的属性和方法。通过类可以创建多个相同类型的对象。
>
> 3. 封装（Encapsulation）：封装是一种将数据和方法绑定在一起的机制，隐藏对象内部的实现细节，只对外部暴露必要的接口。通过封装，可以保证数据的安全性和一致性，同时提高代码的可维护性和复用性。
>
> 4. 继承（Inheritance）：继承是一种通过定义一个新的类来继承现有类的属性和方法的机制。继承可以实现代码的重用和扩展，子类可以继承父类的特性，并可以在此基础上进行修改或增加新的特性。
>
> 5. 多态（Polymorphism）：多态是指同一种操作作用于不同的对象，可以有不同的解释和执行方式。多态使得程序能够根据实际对象的类型来调用相应的方法，提高了代码的灵活性和扩展性。
>
> 封装、继承和多态是面向对象编程的三大特性：
>
> - 封装：通过封装可以将数据和方法组合在一起，隐藏内部实现细节，提供简单的接口供其他对象使用，实现了信息的隐藏和保护。
>
> - 继承：通过继承可以基于现有类创建新的类，继承已有类的属性和方法，实现代码的重用和扩展。
>
> - 多态：多态允许不同对象对同一操作有不同的实现方式，通过统一的接口进行调用，提高了代码的灵活性和可扩展性。
>
> 这些概念和特点使得面向对象编程能够更好地模拟现实世界的问题，提高代码的可维护性、可扩展性和可重用性。



2、什么是异常处理?通常有哪些方式进行异常处理?

- 异常：程序执行过程中出现的错误、异常条件或意外情况，可能导致程序中断、崩溃或产生不正确的结果。
- 异常处理：提前处理，确保可靠性
- 处理方式
  - 抛出
  - 捕获
  - 记录
  - 恢复



# 笔试算法

[EndlessCheng/codeforces-go: Golang 算法竞赛模板库 | Solutions to Codeforces by Go 💭💡🎈](https://github.com/EndlessCheng/codeforces-go)



目前

- 双指针、字符串考得特别多
- 似乎现在还喜欢考高精度，遇到过乘法和加法了，不知道为什么
- go 特别容易考协程输出，其他也基本就问问 go tour 里面的，熟悉那个就好了，再难就是场景题，比如鳄梨上次的高并发短链接服务设计。







# 真实面经整理和简单反思

### 百度一面 0724

> 标日期是为了查日记



1. 自我介绍
2. go里面是怎么并发是怎么调度，调度是如何实现的，提示 GMP模型



- GMP模型
  - 组成介绍
  - 基本运作
- 关键是具体的调度
  - work-stealing 平衡负载
  - p pool 中的 p来管理 g的调度
    - 宏观调度机制
    - 根据情况选择四种调度方式，自适应调整参数
  - 具体的一些调度策略
    - 被动调度的流程中会有自动休眠





你知道内存分配的原则吗？

- 实践：map和strig slice 尽量预分配？
  - copy让大内存回收掉



好像确实搜不到这个问题的答案，也暂时搞不清具体想问什么，先这样了解一下，好像也还不错

> Go 语言中的内存分配有以下几个原则：
>
> 1. **零值分配**：在 Go 语言中，通过 `var` 关键字或没有显式初始化的声明创建变量时，会自动分配相应类型的零值。例如，数值类型的零值为 0，字符串类型的零值为空字符串，指针类型的零值为 nil 等。
>
> 2. **堆分配**：当使用 `new` 或 `make` 函数创建新的数据结构时，它们会在堆上分配内存。`new` 函数适用于任意类型的分配，而 `make` 函数主要用于分配引用类型（如 slice、map 和 channel）。
>
> 3. **逃逸分析**：Go 语言中的编译器会进行逃逸分析来确定变量的生命周期。如果变量的生命周期超出当前函数的作用域，编译器会将其分配到堆上，否则会分配到栈上。**在栈上分配的变量更加高效，因为它们的内存管理由编译器自动处理，而不需要垃圾回收的参与。**
>
> 4. **复用分配**：Go 语言中的内存分配器有一个复用机制，它会尽可能地复用已经释放的内存，而不是频繁地进行内存分配和释放。这样可以减少内存碎片和提高性能。
>
> 5. **小对象优化**：Go 语言的内存分配器会对小对象进行特殊处理，通常将它们分配在连续的小块内存上，从而提高内存分配和访问效率。
>
> 6. **内存对齐**：Go 语言会对结构体和数组等数据进行内存对齐，以便于 CPU 访问。在某些情况下，**编译器会在数据结构之间插入【填充字节】**，以满足 CPU 对齐的要求。
>
> Go 语言的内存分配由运行时系统管理，它在后台执行垃圾回收，自动回收不再使用的内存，确保程序在内存使用上的高效和安全。了解这些内存分配原则可以帮助开发者编写高效的 Go 代码，避免不必要的内存分配和性能损失。





了解过GC原理吗？

- 基于并发标记和并发清除
- 三色标记和混合写屏障的优化





C++内存对齐的原理， 有哪些方式 / 怎么做到的，它的作用 / 为什么要做内存对齐？

> C++ 内存对齐（Memory Alignment）是一种优化技术，它主要是为了提高程序的执行效率和内存访问速度。内存对齐的原理是让数据结构的起始地址和每个成员的地址都符合特定的对齐规则，通常是成员的地址是它的大小的整数倍。
>
> C++ 中的内存对齐主要通过以下方式实现：
>
> 1. **默认对齐方式**：C++ 标准没有强制规定结构体或类成员的对齐方式，但大多数编译器默认按照 CPU 架构的对齐要求进行内存对齐。通常情况下，成员的对齐要求是其大小（字节数）的最小公倍数和编译器的字节对齐要求中的较小者。
>
> 2. **指定对齐方式**：C++11 引入了 `alignas` 关键字，允许程序员显式指定结构体或类成员的对齐方式。通过 `alignas` 关键字，可以覆盖编译器默认的对齐方式，以满足特定需求。
>
> 内存对齐的作用和优势有以下几点：
>
> 1. **提高访问效率**：内存对齐使得数据结构的成员在内存中排布更加紧凑，减少了 CPU 访问数据时可能涉及的读取次数，从而提高程序的执行效率。
>
> 2. **避免内存碎片**：合理的内存对齐可以避免内存碎片的产生。如果结构体或类成员没有对齐，可能导致空洞出现，造成内存浪费。
>
> 3. **硬件兼容性**：某些硬件平台要求数据的访问必须满足特定的对齐要求，否则可能引发硬件异常。通过内存对齐，可以确保程序在不同硬件平台上的兼容性。
>
> 4. **结构体内存布局的一致性**：内存对齐可以保证不同编译器和不同平台下，结构体的内存布局是一致的，从而方便数据的传递和存储。
>
> 总的来说，C++ 内存对齐是一种性能优化手段，它可以提高程序的执行效率、减少内存浪费，以及保证程序在不同硬件平台上的正确性和一致性。在编写 C++ 程序时，合理使用内存对齐技术是一个重要的优化策略。



3. 直接从第二个项目引入，具体去说第二个项目的内容



讲讲你知道哪些关于微服务的内容？为什么方便部署？



了解这个微服务之间它们之间的调度吗？就是说比如说我现在一个服务，一个单体服务，嗯，划分出来了，比如说就几十个服务，微服务这个之间他们的调度他怎么去管控。



假设我说这个你的服务一个单体服务，现在划分出来几十个乃至更多，然后这个时候你某一些服务出现故障了，要及时做迁移，那他怎么做的？

（讲了一堆，然后说没学过k8s，过）
4. MySQL 选择B+树 + 哈希的原理，为什么不用红黑树。
5. Redis 哪些数据结构支持设置过期时间
6. 计数服务是怎么设计的？（我说了用 go channel 的那个快慢队列的版本，然后他问我为什么不只用redis，然后就不会了）
7. Python 在就是说一定的这个场景下。这个场景我现在不告诉你。就是在一定的场景下，它的就是所谓的多线程和多进程，你觉得哪个更有优势？你能不能分别介绍一下？
最后：反转字符串 算法题





### 边无际一面 0725

1. LangChain 做了哪些应用（公司也有在做这个的）
2. 算法：go实现高精度加法
3. 解释一下 channel goroutine defer
   1. 有缓冲的 channel 和没有缓冲的有什么区别
   1. （后来才知道 goroutine != 协程。。）
4. 反问





### 字节人工智能编辑一面 0727

> 别误会了，和送外卖也是进大厂差不多的意思，这个岗位的工资不知道比不比得过字节清洁工



1. 算法一个 DFS 判环和一个 goroutine交替输出12（后面这个考得很频繁）

2. GIN 框架的好处？其实就是性能强，比原生框架快很多，感觉一般倒是不会问

3. 最新特性有了解吗？

   fuzzing 模糊测试，在不知道输入的情况下进行大量测试来探测边界

   最新版本中还有脆弱依赖检测的特性

4. new 和 make 的区别

   > 
   >
   > 1. **`make` 函数**：
   >    - `make` 函数用于创建切片、映射（map）和通道（channel）这三种**引用类型**的数据结构。
   >    - `make` 函数的语法为：`make(T, size)`，其中 `T` 表示切片、映射或通道的类型，`size` 表示切片或映射的长度（容量对于映射无效）或通道的缓冲区大小。
   >    - `make` 函数返回的是对应引用类型的实例，初始化为其零值，并分配了对应类型的内部数据结构。
   >
   > 2. **`new` 函数**：
   >    - `new` 函数用于创建并初始化某种类型的指针，并返回指向新分配的内存的指针。
   >    - `new` 函数的语法为：`new(T)`，其中 `T` 表示要分配内存的类型。
   >    - `new` 函数返回一个指向类型 `T` 的零值的指针，而不是一个实例。在返回的指针上，所有字段都被初始化为类型 `T` 的零值。
   >
   > 简要总结两者的区别：
   >
   > - `make` 用于创建切片、映射和通道等引用类型的实例，返回实例本身。
   > - `new` 用于创建并初始化某种类型的指针，并返回指向新分配的内存的指针，**支持所有类型**。
   >

   - make感觉也可以说返回的是指针，但是只有三种**引用类型**，确实是特殊的，定义和左右可能都是函数传递的时候会直接传指针，会直接改变值。而new适用于可能结构体，然后传的时候需要手动传指针，不然直接传的就是值了
   - 「引用类型」共同特点
     - 上面说的【传递引用】
     - 可变、动态长度、空值nil（这个不是特有的）

5. 多态的定义（面试官好像还都挺关注你也熟悉其他语言的）

   同一接口，不同消息，同一对象，不同行为。例子：重载、泛型

6. LangChain 做过哪些事情？

   暂时确实不多，说好确实做过的就行了，最近抽不出时间，有空确实多放纵兴趣多研究一点。这种真的属于是，你研究了什么都作数的，面试的时候都可以说。

7. 介绍一下做过的项目？有哪些难点值得分享？

   还真没准备，目前可以说的一个就是第二个项目的架构演变，可以多练习几次。

   其他暂时确实没什么说的，可以说说 JWT、FEED实现设计然后计数服务的构思（但是承认没写完，）

   







### 字节人工智能编辑HR面 0728

> HR面其实还是要重视的，还是要学会怎么好好表达出自己综合素质比较强

1. 自我介绍

   1. HR面的话技术全面而一笔带过就好了，可以把技术栈和特别擅长的地方说一下就差不多了。能自我介绍清除也是一种能力
   2. 其他其实也可以和简历挂钩，就自己简历最后一栏。其他也可以说说
      1. 信息搜集整理能力强
      2. 热爱新兴技术
      3. 学习能力还不错（就不要提自己其实不擅长深耕一个技术），比较善于解决问题

2. 考研还是就业

   不要说不想考研，说倾向于直接就业，提升自己能力最重要，也是积极向上就差不多了

3. 用三个要点来介绍自己（结果导向→例子说明→逻辑词语（“我觉得xxx，首先，其次，最后，所以我认为xx））

   1. 善于总结反思
   2. 善于团队协作，与人打交道，性格温和
   3. 工作热情高、热爱软件事业

4. 如何证明你自己善于团队协作

   1. 担任过队长，解决过一些矛盾。使用的方法：积极反馈鼓励，重视细节，重视合理性，积极沟通

5. 跨公司的一些要点可以准备好，字节的话其实本来就挺好夸的，整理一下可以说

   1. 开源贡献
   2. 同类产品横向比较
   3. 其他比如说社会贡献、青训营和其他公益项目等
   4. 是个喜欢上网冲浪的人，可以看到在国际上地位非常高，很早以前还挺想去外企的，但是后来才觉得字节有外企想要的一些特质但是却是中国企业。

6. 然后那你未来就业的话，你会选择什么样的企业？

   应该无所谓，大厂优先、积极向上就差不多了。

7. 如果说你在这个过程中跟你的 mentor 和 leader 他们产生了一些意见上的冲突的话，你会怎么去处理？

   虚心吸收意见但是保持自己一份看法

8. 要是工作不符合预期，你会怎么做？（地狱问题）

   （这次感觉还好，这种问题可能都是，不要太假就差不多了，也不至于你稍微说想走就不入职了）

   首先预期很低，其次自己适应能力很强。

   如果实在不符合预期，可能还是会考虑不继续下去，毕竟不能对公司有很大的贡献。

   比较标准的回答：https://www.xiaohongshu.com/discovery/item/63edf7980000000013030429?app_platform=android&app_version=7.89.0&author_share=2&share_from_user_hidden=true&type=normal&xhsshare=WeixinSession&appuid=604d80510000000001009505&apptime=1690531360

   - 表示理解
   - 适应能力强（有心理准备）
   - 原则性差异，本着对公司负责离职；不然自己能适应。
   - 不是很想去，不是很相信就直接反问了



### 疯狂游戏一面 0728

> 问得倾向性很强，非常有收获的一次面试。
> 更倾向于问，你这个技术应用到实际业务场景中的理解。

1. 介绍项目

2. 对 Feed 流很感兴趣，问了深入设计，我之前看过一些角度用上了，还不错。

   数据库分表？

3. defer 的应用场景，wg的应用场景

4. `select` 的使用：

   1. 在实际工程中有哪些应用场景？

      > 在 Go 中，`select` 是用于处理并发操作的关键字，主要用于多个通道之间的选择和控制。`select` 的使用场景在实际工程中非常丰富，下面列举了一些常见的应用场景：
      >
      > 1. **多路复用**：`select` 可以同时监听多个通道，一旦其中一个通道有数据可读或可写，`select` 就会触发相应的操作，实现了多路复用。
      >
      > 2. **超时处理**：通过在 `select` 中结合 `time.After`，可以实现对某个操作的超时处理，避免长时间阻塞。
      >
      > 3. **任务调度**：`select` 可以用于任务调度，通过监听不同的通道，执行不同的任务。
      >
      > 4. **通信与同步**：在并发编程中，`select` 可以用于通信和同步多个 goroutine 之间的操作。
      >
      > 5. **连接池**：在网络编程中，`select` 可以用于管理连接池，监听多个连接的可用性和请求。
      >
      > 6. **限速器**：通过 `select` 和带缓冲的通道，可以实现限速器，限制某个操作的频率。
      >
      > 7. **优雅退出**：`select` 可以与 `context.Context` 结合，实现优雅的退出，即在接收到退出信号时，安全地关闭所有 goroutine 和资源。
      >
      > 8. **并发控制**：通过 `select` 和带缓冲的通道，可以实现对并发的控制和调节。
      >
      > 这些只是 `select` 在实际工程中的一部分应用场景，其灵活性和强大功能使得它成为了 Go 语言中处理并发编程的重要工具。在实际工程中，合理使用 `select` 可以帮助优化并发代码，提高程序的性能和效率。

   2. 如何利用 `select` 来设计一个五秒的超时？

      （答了个 for，寄了，这个其实是 go tour 教的，但是忘了）


      这个关键是 `time` 这个包，它是一个计时会自动准备好的单向通道，之前想看源码但是忘了

5. 你自己觉得自己有哪些比较牛逼的点可以介绍

   1. 。
      1. 答了算法基础，go基础，然后也诚实说了go不敢说很深入，然后AI也说了说挺好的
      2. 后面确实要好好深耕并且准备
      3. 然后漏答的东西，其实也可以说说，自己涉猎的技术广泛吧，从前端到后端，从部署到项目管理，还精通git原理，有一个关键是自己确实还比较擅长使用工具（AI工具，代码fu'zhu
   2. 观察过什么？了解过什么？

6. 排序算法

   1. C++默认排序算法

      > C++的STL（标准模板库）中的排序算法主要是通过 `std::sort` 函数实现的，它采用了一种优化的混合排序算法。具体实现可能因不同的编译器和标准库而有所不同，但一般而言，`std::sort` 函数采用了三种排序算法的混合使用，根据数组的特征选择最优的算法：
      >
      > 1. **插入排序（Insertion Sort）**：对于小规模的数组（通常少于一定的元素个数），插入排序是一个高效的算法，因为其时间复杂度为 O(n^2)。对于这样的小规模数组，`std::sort` 会采用插入排序来进行排序。
      >
      > 2. **快速排序（Quick Sort）**：快速排序是一种常见且高效的排序算法，其平均时间复杂度为 O(n log n)。对于大规模的数组，`std::sort` 会采用快速排序来进行排序。
      >
      > 3. **堆排序（Heap Sort）**：堆排序是另一种高效的排序算法，其时间复杂度也为 O(n log n)。对于一些特殊的情况，如数组存在大量相同元素时，堆排序可能表现得更好。在这种情况下，`std::sort` 会采用堆排序来进行排序。
      >
      > 混合排序算法的选择是根据数组的特征进行动态调整的。`std::sort` 会在排序的过程中根据数组的大小和元素的分布情况来选择合适的排序算法。这样可以在大多数情况下保证 `std::sort` 的性能表现是相对高效的。
      >
      > 需要注意的是，`std::sort` 在最坏情况下的时间复杂度为 O(n^2)，但在实际应用中，它通常表现得非常高效。如果需要对数组进行排序，推荐使用 `std::sort` 函数，它是标准模板库中的一个重k要算法，并且在大多数情况下都可以提供高性能的排序功能。

   2. 快速排序的优势

      > 快速排序在大多数情况下被广泛采用的原因是它具有以下几个优势：
      >
      > 1. **平均时间复杂度较低**：快速排序的平均时间复杂度为 O(n log n)，这意味着在平均情况下，它的排序速度是相对较快的。
      >
      > 2. **适用于大规模数据**：快速排序在处理大规模数据时表现良好。它的时间复杂度是渐进最优的排序算法之一，对于数百万、数亿甚至更大规模的数据，快速排序通常是较为高效的选择。
      >
      > 3. **内存占用较低**：相较于一些其他高级排序算法（如归并排序），快速排序所需的辅助内存空间较少，仅需要递归时的栈空间，因此内存占用较低。
      >
      > 4. **局部性原理**：快速排序采用分治策略，将问题划分为较小规模的子问题进行解决，这种分而治之的思想符合计算机的局部性原理，使得缓存命中率较高，提高了算法的执行效率。
      >
      > 5. **原地排序**：快速排序是一种原地排序算法，即它可以在待排序数组上直接进行排序，而不需要额外的辅助空间。
      >
      > 尽管快速排序在大多数情况下表现良好，但也需要注意，快速排序的最坏情况时间复杂度为 O(n^2)，这种情况出现在数组已经有序或者基准元素的选择不当时。因此，在实际应用中，为了避免最坏情况的发生，可以采用随机化快速排序或其他优化策略来提高算法的稳定性和性能。

   3. PDQ

      > PDQ（Pattern-Defeating Quicksort）排序算法是由Daniel Lemire等人在2019年提出的一种快速排序算法的改进版本。PDQ排序算法的目标是通过优化一些常见情况，提高快速排序的性能，尤其是在现代CPU架构下。
      >
      > PDQ排序算法相比传统的快速排序算法有以下几个改进点：
      >
      > 1. **三数取中法**：PDQ排序算法采用了三数取中法来选择基准元素，而不是简单地选择数组的第一个元素。三数取中法是一种基准元素选择的优化策略，它可以避免在最坏情况下的不平衡划分，提高排序的稳定性。
      >
      > 2. **自适应划分策略**：PDQ排序算法采用了一种自适应的划分策略，根据数组的特征来选择合适的划分策略。在数组存在大量相同元素时，PDQ排序算法会使用优化的划分方法，减少划分的开销。
      >
      > 3. **插入排序优化**：PDQ排序算法在划分过程中，对于小规模的子数组会采用插入排序来进行排序，这是因为插入排序对于小规模数组是高效的。
      >
      > 4. **优化的递归策略**：PDQ排序算法采用了优化的递归策略，减少递归的层数，从而降低递归开销。
      >
      > 通过上述优化，PDQ排序算法在大多数情况下表现得比传统的快速排序算法更好。它在现代CPU架构下能够更好地利用缓存和流水线等硬件特性，从而提高排序性能。
      >
      > 总体来说，PDQ排序算法是一种在实践中表现优异的快速排序算法，它结合了多种优化策略，使得排序在各种情况下都表现得相对稳定和高效。

7. 说一下那个那Docker，因为其实后端其实对 Docker 要求是挺高的，就你平时用 Docker 的时候都会怎么。

8. 用过那个Redis，嗯，你用 Redis 就是做项目的时候你就用它做过什么业务，就是任何一个就功能模块都可以，你说。

   1. 什么不写内存里，非得写在 Redis 里？

      1. 可以答优势：持久化、支持事务、分布式主从复制

      2. 但是面试官想听到的其实是：无状态服务

         1. 无状态其实好像听过，大概就是意味着不存储服务器

            > 无状态服务是指在处理请求时**，服务端不会保存任何会话状态，每个请求都是独立的，服务端不需要记住之前的请求信息。**
            >
            > 以下是Redis无状态服务的特性：
            >
            > 1. **无连接性**：Redis是基于TCP协议的无连接服务，即每次客户端发送请求时都需要建立一个新的连接。服务端不会维持客户端连接状态，每次请求都是独立的。
            >
            > 2. **无会话状态**：Redis不会保存任何会话状态，它不会记录之前的请求信息或上下文数据。每个请求都是独立的，服务端不会依赖之前的请求来处理当前的请求。
            >
            > 3. **请求-响应模型**：Redis遵循请求-响应模型，每个请求都会有相应的响应返回给客户端。服务端不会主动推送信息给客户端，客户端需要主动发送请求来获取数据。
            >
            > 4. **线程安全**：由于Redis是无状态服务，没有共享的状态信息，因此它天然是线程安全的。多个线程可以同时处理请求，不需要考虑数据的同步和互斥问题。
            >
            > 5. **高并发性**：无状态服务的特性使得Redis能够处理大量的并发请求。每个请求都是独立的，不会受到其他请求的影响，因此可以有效地处理大量的并发访问。
            >
            > 6. **水平扩展**：由于Redis是无状态服务，它可以很容易地进行水平扩展。可以通过增加多个Redis节点来分担负载，实现高可用和高性能的集群部署。
            >
            > 无状态服务的特性使得Redis具有高性能、高并发和易扩展等优势。它适用于处理大量的读写请求，并且可以方便地部署在分布式环境中，满足现代Web应用对性能和可扩展性的要求。

         2. 

9. 反问

   1. 吃力的面试反问“要是没过，您有什么建议”确实挺好的

10. 给的建议和不足

    1. 给人一种面试不认真的感觉。项目深度不够。一般问那种问题，要答到两层。
       1. 官方的实现。有哪些牛逼的源码实现
       2. 我项目中怎么用的，最好还能是最佳实践

> 你想写那个东西的谁不会啊？对，我就背呗，然后再有说，我当然没有这么简单，就是会不会无所谓，就是都是点 SOT 嘛，对吧？就是谁会在真正的项目里边用这玩意？它主要是一个培养的一个思维，就是为什么用才会培养这个思维，就是能用这件事不培养思维，不行。
> 我懂了，你举个例子，咱们未来咱俩可能共事，然后你是个服务器，那服务器里面其实比客户端要关注的更多东西，实际上就是OK，虽然只是增删改查，那这个增删改查它的比如说 CPU 的使用率，它的那个复杂的有多复杂，对吧？它用到了哪些？比如说MySQL、Mongo，然后它的那个基本的一个时间复杂度是什么程度，对吧？其实这些东西都是平时的一些对这些算法、数据结构的一些理解，然后的感受最终都是形成感受的，对吧？哪有那么多项目说，我天天压测，我压测到它这个上限是什么？多少万的OPS，没有项目的，就是我跟你说小项目没有人能干这活，一般都是靠经验。
