---
tags: [知识点记录, CSAPP]
---



认识过程：

- 过程并不是描述整个代码运行流程一个术语，而表示的是代码的一个部分，是软件中非常重要的一种抽象
- 不同语言的语言的「过程」形式不一（function, method, subroutine, handler)，但是也有一些共同的特性：
  1. 传递控制。切换过程的时候把原来下一条指令的地址压栈，然后将程序计数器设置为过程的第一条指令。
  2. 传递数据。必须向过程传参以及必须返回值？
  3. 分配和释放空间。



###  The Run-Time Stack

- x86-64虚拟地址空间中的栈向低地址方向延展，栈指针 `%rsp` 指向栈顶低地址

  ![image-20230114111927984](https://f.pz.al/pzal/2023/01/14/1a8cf6461d356.png)

- 栈帧：x86-64这种ISA中的过程需要的存储空间寄存器放不下的时候，超出的部分就会被分配到栈上，这整个栈的部分被称作是栈帧。

  栈帧被依次用于：

  1. 较早的帧
  2. 传递参数
  3. 存储返回地址
  4. 存储保存的寄存器
  5. 存储局部变量
  6. 局部参数构造



![image-20230114124929756](https://f.pz.al/pzal/2023/01/14/24511b3693083.png)

> 例子：只有六个寄存器，多出来的部分存入 Stack Frame

（x64中栈无论数据类型的长度都是按8对齐的)



### 转移控制

函数调用返回的过程

先把返回地址压入栈中，然后等函数（过程）执行完毕，弹出之前压入的地址，存入指令寄存器中

![image-20230114113122424](https://f.pz.al/pzal/2023/01/14/268af63fc0a9d.png)

顺带记录一下指令寄存器（IR）和程序计数器（PC / `%rip`）的区别：

|      |        存的内容        |                   说明                   |
| :--: | :--------------------: | :--------------------------------------: |
|  IR  | 下一条要执行的指令本身 |     和汇编代码的指令寄存说明有些不同     |
|  PC  |   正在执行的指令地址   | 要是没跳转就能够直接 $+1$ 指向下一条指令 |





### 数据传送

- 传参使用寄存器的时候是有顺序规定的，同时和参数序号和和操作数长度有关

  ![image-20230114125415927](https://f.pz.al/pzal/2023/01/14/0bb406646cde8.png)



### 局部存储

#### 栈上局部存储

- 栈通过加减 `%rsp` 来分配和释放空间，提供「内存分配与回收机制」
- 这里可以实例性地看到寄存器存储参数和栈帧存储的不同

 ![image-20230114125618040](https://f.pz.al/pzal/2023/01/14/a18209a52beb3.png)



#### 寄存器上局部存储

- 寄存器分为两类

  ![image-20230114134439063](https://f.pz.al/pzal/2023/01/14/9729e0a81d31c.png)

  其区别就是在哪个函数的指令段压栈



- 了解递归函数调用的过程
  ![image-20230114135600574](https://f.pz.al/pzal/2023/01/14/de2eafc32ca02.png)
  - `.L35` 就是一个条件跳转的标记，这里表示递归出口
  - 每个函数都有各自私有的状态信息，而当他们需要访问状态信息的时候正好和栈的弹出顺序相同
