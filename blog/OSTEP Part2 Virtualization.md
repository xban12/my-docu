---
tags: [操作系统]
---



## 进程的抽象



关键问题：如何提供多个CPU的幻觉？

- OS 在时间上会将 CPU 共享到多个进程
- 规划器会挑选将会在CPU上执行的进程
  - 挑选规则
  - 上下文转换机制



进程的组成

进程是OS对运行程序的抽象，实质上是由内存存储的指令组成的

- PID
- image
  - 静态的代码和数据
  - 动态的栈和堆
- CPU 上下文存储在寄存器
  - PC
  - 操作数
  - 栈指针
- 文件描述器
  - STDIO



进程的创建

- 分配内存和创建镜像
- 打开基础文件
- 初始化CPU寄存器



状态

- 运行中
- 准备
- 阻塞
- 新创建
- 死亡



状态转换



数据结构

- OS 维护一个数据结构来存储所有进程
- 进程的信息被存储在 PCB 中



## 系统调用与进程管理



API

- 给用户提供写程序的函数
- 操作系统题提供的 API 允许进行一些系统调用
  - 高特权
  - 敏感行为
  - 一些阻塞操作



是否可以重写 OS 的程序

- POSIX API：OS 必须要实现的
- 程序语言会隐藏系统调用的细节



和系统调用有关的进程

- `fork()`
  - fork 以后马上开始独立同时运行，返回不同的值
  - 使用不同的内存
  - 等子进程结束
- `exec()`
  - 可以让子进程运行一个和父进程不同的程序

- `wait()`
- `exit()`



父进程会等待子进程结束

- 进程可能正常通过 `exit()` 结束，也有可能意外结束
- 子进程先结束，会变成僵尸僵尸进程不会马上被移除
  -  `wait()` 可以重新获取或者直接清理掉子进程，具体暂时不清楚



Shell 是怎么工作的

- 一般的操作系统中，硬件初始化以后会创建一个 `init` 进程
- 进程会生出像 `bash` 一样的 Shell
- Shell 是用来读命令，执行程序，和程序 交互的工具 



 

## 进程执行机制



进程的执行

- 分配内存和创建镜像
  - 代码和数据（从可执行文件）
  - 栈和堆
- PC SP 指向指令
- OS 脱离战线，直接任务交给CPU





简单的函数调用

- 函数调用其实就是指令的跳转
- 主要用到了栈区，压入源地址，原值，返回值，函数参数，更新SP



系统调用的区别

- CPU 有更高级的特权：两种执行代码的模式，用户模式和内核模式
- 内核是不相信用户的
  - 栈分离
  - 跳转地址也会不被信任
    - 内核在启动的时候会有一个叫 IDT 的跳转表用于查阅



系统调用机制

陷入指令

- 当执行系统调用的时候，陷入指令一般回会启动（一般会隐藏
- 执行过程
  - 把CPU移动到高特权等级
  - 移动到内核栈的镜像
  - 保存上下文转移
  - 查 IDT
- 执行的情况
  - 系统调用：程序需要OS的服务
  - 程序异常
  - 正常中断（比如外部网络输入
- 基本机制都是
  - 把上下文保存到内核栈
  - 切换到IDT中的OS地址
- IDT 的使用
  - 系统调用或者中断的前，都会保存一个当前寄存器的序号
- 从陷入中返回
  - 执行一个特殊的返回指令
    - 恢复上下文
    - 改变CPU特权
    - 恢复PC返回用户代码
  - 系统调用的内容用户无从得知



为什么需要切换到不同进程

- 不能返回原进程
  - 已经退出或者意外终止
  - 进程阻塞了系统调用
- 不想回到原进程
  - 进程已经运行太久了
  - 需要与其他进行进行 CPU 分时





OS 调度（进程调度

- 两大部分
  - 选择进程
  - 切换进程
- 切换
  - 抢占式
  - 非抢占式
    - CPU 生成周期式计时器中断
    - 一次来检查当前进程是否运行太久了



上下文切换机制

- 步骤
  - 保存上下文：PC，寄存器，KSP U to K
  - SP
  - 恢复 K 上下文
  - 谁保存了 K 进程原来的 SP？
    - OS
- 巧妙之处
  - 模式切换的时候陷入指令会保存用户上下文到内核栈
  - 上下文切换的时候，内核上下文会被模式切换的指令保存到内核栈
- 系统调用不一定创建新进程
  - 进程没有用户和内核之分，而是进程有不同的执行模式







## 调度



在前面的章节中讲清楚的低等级的上下文切换，这个章节会详细讨论进程的调度

**关键问题，调度策略是怎么发展出来的**

