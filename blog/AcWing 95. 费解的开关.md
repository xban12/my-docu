# AcWing 95. 费解的开关 

我认为最难理解的问题是：如何把BFS的 $2^{25}$ 中状态的枚举优化成 $2^{5} \times (4 \times 5)$ ，也就是 $2^{20} \to 20$ ？


这是我整理的要点：

- 没必要枚举所有可能的状态的原因是：我们只需要枚举**“有可能让全部的灯亮起来的状态”**即可

- 有些状态，我们只看前两行就知道不可能得到答案。比如说第一行有 $0$ 但是第二行却没开过灯。

- 递推就是基于这种“行与行之间的联系”的 ，我们具体的做法是
  - 从第一行开始递推，先枚举第一行所有“开关可能性”，将其确定下来。
  - 然后我们去检查第一行，既然我们第一行开关的可能性已经确定了，那么我们加入在第一行看到了 `0` ，那我们**第二行的对应列数的灯**就必须打开
  - 循环检查完四行以后，所有「可能成功的方案」就已经确定下来了（最后一行的状态在检查第四行的时候已经枚举完），这时我们对最后一行做最后的检查（我们之前确保了前四行，但是最后一行才是**最开始第一行状态最终是否可行**的决定性因素），得到当前方案的步数




主要问题解决了，剩下就简单了



递推部分参考代码：

```c++
void res(){
    int ans = INT_MAX;

    for(int op = 0; op < 1 << 5; ++op){
        int steps = 0;
        memcpy(backup, g, sizeof g);

        for(int j = 0; j < 5; ++j)
            if(op >> j & 1) {
                ++steps;
                turn(0, j);
            };

        for(int i = 0; i < 4; ++i)
            for(int j = 0; j < 5; ++j)
                if(g[i][j] == '0') {
                    ++steps;
                    turn(i + 1, j);
                }
        
        bool ok = true;
        for(int j = 0; j < 5; ++j) ok &= (g[4][j] == '1');

        if(ok) ans = min(ans, steps);

        memcpy(g, backup, sizeof backup);
    }

    if(ans > 6) cout << -1 << '\n';
    else cout << ans << '\n';
}
```

